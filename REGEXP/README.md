# 正则速查表

![banner](./images/regex.jpg)

自己收集了一套针对工作中所需的正则表达式. 多适用于字符串处理、表单验证、日志数据分析等场合，实用高效, 将长期维护。

> Tips：在本文找想要的正则时，可以尝试使用浏览器的快速查询功能。`Ctrl + F`输入关键字能提高查询的效率哟~

----

## 常用的正則方法示例

**replace:**

``` javascript
// 使用正则匹配中文字节, 将其替换为xx, 再获取字符串的长度就是完整的长度了.
function getLen(str) {
  return str.replace(/[^\x00-\xff]/g, 'xx').length;
}
```

**test:**

``` javascript
// 匹配是否符合邮件规则
var reg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;

// test返回一个布尔值, 表示是否匹配到制定字符串
var mail = reg.test('anran758@gmail.com')

if (mail) {
  // 如果邮件格式正确的话, 就可以做点啥了(雾
}
```

### 常见的表单验证

``` javascript
// 用户名正则，4到16位（字母，数字，下划线，减号）
var userNameReg = /^[a-zA-Z0-9_-]{4,16}$/;

// 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var passwordReg = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;

// 匹配邮箱地址
var mailReg = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;

// 中国六位数的邮政编码
var postalCode = /^\d{6}$/;

// 匹配15~18位身份证
var IDCard = /(^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$)|(^[1-9]\d{5}\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{2}$)/;

// 匹配18位的新版身份证
var IDCard_18 = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;

```

### 网络相关

``` JavaScript
//ipv4地址正则
var IPReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

// Reg Hex颜色正则
var pattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;

// URL正则
var urlReg= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

// 匹配JSON格式
var reg = /^\w+\(({[^()]+})\)$/
```

匹配`json`字符串

``` JavaScript
var ret = response.data;
if (typeof ret === 'string') {
  var reg = /^\w+\(({[^()]+})\)$/
  var matches = ret.match(reg);

  if (matches) ret = JSON.parse(matches[1]);
}
res.json(ret);
```

### 联系方式

``` JavaScript
// 5-11位的腾讯qq号
var qqReg = /^[1-9][0-9]{4,11}$/;

// 微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
var qqReg = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;

// 国内常见
var phone = /^1[3|5|8|9]\d{9}$/;

// 固定电话
var telephone = /^(0[0-9]{2})\d{8}$|^(0[0-9]{3}(\d{7,8}))$/;
```

### 匹配特定数字

``` javascript
// 匹配正整数
var reg = /^[1-9]\d*$/;

// 匹配负整数
var reg = /^-[1-9]\d*$/;

// 匹配整数
var reg = /^-?[1-9]\d*$/;

// 匹配非负整数（正整数 + 0）
var reg = /^[1-9]\d*|0$/;

// 匹配非正整数（负整数 + 0）
var reg = /^-[1-9]\d*|0$/;

// 匹配正浮点数
var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$/;

// 匹配负浮点数
var reg = /^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$/;

// 匹配浮点数
var reg = /^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$/;

// 匹配非负浮点数（正浮点数 + 0）
var reg = /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$/;

// 匹配非正浮点数（负浮点数 + 0）
var reg = /^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$/;
```

### 字符串相关

``` javascript
// 匹配由26个英文字母组成的字符串
var reg = /^[A-Za-z]+$/;

// 匹配由26个英文字母的大写组成的字符串
var reg = /^[A-Z]+$/;

// 匹配由26个英文字母的小写组成的字符串
var reg = /^[a-z]+$/;

// 匹配由数字和26个英文字母组成的字符串
var reg = /^[A-Za-z0-9]+$/;

// 匹配由数字、26个英文字母或者下;划线组成的字符串
var reg = /^\w+$/;

// 匹配空白行的正则表达式
var reg = /\n\s*\r/;

// 匹配首尾空白字符的正则表达式
var reg = /^\s*|\s*$/;
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// 匹配双字节字符(包括汉字在内, 一个双字节字符长度计2，ASCII字符计1)
var reg = /[^\x00-\xff]/g;
```

----

### 正则技巧

#### 反向引用

``` javascript
// 比如这里我们想让这个日期格式反转
// 正则括号是一个分组, 下面的代码就捕获了三个分组
// 通过$分组符来转换位置, 来达到我们想要的结果
'2018-3-21'.replace(/(\d{4})-(\d{1,2})-(\d{1,2})/g, '$2/$3/$1') // "3/21/2018"
```

#### 忽略分組

不希望捕获某些分组, 只需要分组内加上`?:`即可:

``` javascript
var reg = /(?:Byron).(ok)/;
'Byron-ok'.replace(reg, '$1');  // 只匹配了 ok
```

#### 前瞻

| 名字     | 正則          |
| -------- | ------------- |
| 正向前瞻 | exp(?=assert) |
| 负向前瞻 | exp(?!assert) |

正向前瞻就是匹配前者, 效验后者是否存在.

``` javascript
// 这个正则的意思是: 匹配一个单词字符( [a-zA-Z0-9_] ), 然后验证后面是不是数字
// 结果为: "X2*3". 因为3后面没有数字, 所以没有匹配到.
'a2*3'.replace(/\w(?=\d)/g, 'X')

// 结果为: "X2*X4X8"
// 总的说就是
'a2*34v8'.replace(/\w(?=\d)/g, 'X')
```

负向前瞻则相反, 匹配前面, 替代后面

``` javascript
// a 是单词字符, 后面是数字, 因此没有匹配到
// 2 是单词字符, 后面不是数字, 被替换成X
// * 不是单词字符 因此没有匹配到
// 3 是单词字符, 后面是数字, 因此没有匹配到
// 4 是单词字符, 后面不是数字, 被替换成X
// v 是单词字符, 后面是数字, 因此没有匹配到
// 8 是单词字符, 后面没有匹配到数字, 被替换成X
// 结果: aX*4XvX
'a2*34v8'.replace(/\w(?!\d)/g, 'X')
```

----

可视化正则表达式, 可以试试[regexper](https://regexper.com/), 让你看懂正则匹配的走向.

![regexper](./images/regexper.png)

最后如果有哪些正则规则有问题的, 可以留言探讨一下呀~