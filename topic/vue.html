<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.43">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icons/logo.svg"><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3eaf7c"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png"><link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c"><meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png"><meta name="msapplication-TileColor" content="#000000"><title>Vue.js | Web 实验室</title><meta name="description" content="Web 开发笔记与解决方案">
    <link rel="modulepreload" href="/front-end-lab/assets/app.7e3542fd.js"><link rel="modulepreload" href="/front-end-lab/assets/vue.html.d61da977.js"><link rel="modulepreload" href="/front-end-lab/assets/vue.html.ec50a369.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.e7c7dfe3.js"><link rel="prefetch" href="/front-end-lab/assets/dev-ops.html.d9074cc4.js"><link rel="prefetch" href="/front-end-lab/assets/git.html.27d18005.js"><link rel="prefetch" href="/front-end-lab/assets/hg.html.ff79f0d9.js"><link rel="prefetch" href="/front-end-lab/assets/jira.html.0c237662.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.810ddd82.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.6469d7a5.js"><link rel="prefetch" href="/front-end-lab/assets/solution.html.5afd378d.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.c71521b0.js"><link rel="prefetch" href="/front-end-lab/assets/books.html.6327d865.js"><link rel="prefetch" href="/front-end-lab/assets/en.html.e7167ed6.js"><link rel="prefetch" href="/front-end-lab/assets/glossary.html.fd131189.js"><link rel="prefetch" href="/front-end-lab/assets/links.html.8332b8c7.js"><link rel="prefetch" href="/front-end-lab/assets/DSA.html.57440d21.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.02a2d028.js"><link rel="prefetch" href="/front-end-lab/assets/browser.html.84c949f3.js"><link rel="prefetch" href="/front-end-lab/assets/complex.html.570ca66e.js"><link rel="prefetch" href="/front-end-lab/assets/css.html.6b4f2d56.js"><link rel="prefetch" href="/front-end-lab/assets/html.html.57c9ce1f.js"><link rel="prefetch" href="/front-end-lab/assets/js.html.38c63a70.js"><link rel="prefetch" href="/front-end-lab/assets/network.html.da899413.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.51a3b96e.js"><link rel="prefetch" href="/front-end-lab/assets/performance.html.63cc74aa.js"><link rel="prefetch" href="/front-end-lab/assets/react.html.36044864.js"><link rel="prefetch" href="/front-end-lab/assets/webpack.html.bb5e5214.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.fd680d38.js"><link rel="prefetch" href="/front-end-lab/assets/theory.html.dbb9f444.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.f8b80dc7.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.a02bc52a.js"><link rel="prefetch" href="/front-end-lab/assets/libs.html.6613741a.js"><link rel="prefetch" href="/front-end-lab/assets/mini-program.html.362a7b5e.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.bced9d1d.js"><link rel="prefetch" href="/front-end-lab/assets/react.html.be089b0c.js"><link rel="prefetch" href="/front-end-lab/assets/typescript.html.b81e302c.js"><link rel="prefetch" href="/front-end-lab/assets/vue.html.6c6310d6.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.01b7fc15.js"><link rel="prefetch" href="/front-end-lab/assets/js.html.e6c64a8b.js"><link rel="prefetch" href="/front-end-lab/assets/404.html.93146c89.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.40f4d2a6.js"><link rel="prefetch" href="/front-end-lab/assets/dev-ops.html.c0960052.js"><link rel="prefetch" href="/front-end-lab/assets/git.html.41537809.js"><link rel="prefetch" href="/front-end-lab/assets/hg.html.17f987b4.js"><link rel="prefetch" href="/front-end-lab/assets/jira.html.68640a9e.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.c58a0cd1.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.deec9f06.js"><link rel="prefetch" href="/front-end-lab/assets/solution.html.6a378377.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.5cc031eb.js"><link rel="prefetch" href="/front-end-lab/assets/books.html.e32a031a.js"><link rel="prefetch" href="/front-end-lab/assets/en.html.d325de39.js"><link rel="prefetch" href="/front-end-lab/assets/glossary.html.7ed66620.js"><link rel="prefetch" href="/front-end-lab/assets/links.html.e82dc647.js"><link rel="prefetch" href="/front-end-lab/assets/DSA.html.15989b65.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.603e7e96.js"><link rel="prefetch" href="/front-end-lab/assets/browser.html.55e7d69d.js"><link rel="prefetch" href="/front-end-lab/assets/complex.html.3ed293bc.js"><link rel="prefetch" href="/front-end-lab/assets/css.html.38794eaf.js"><link rel="prefetch" href="/front-end-lab/assets/html.html.5aec342c.js"><link rel="prefetch" href="/front-end-lab/assets/js.html.cc262594.js"><link rel="prefetch" href="/front-end-lab/assets/network.html.8aef4433.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.9f7ed822.js"><link rel="prefetch" href="/front-end-lab/assets/performance.html.690a0c9d.js"><link rel="prefetch" href="/front-end-lab/assets/react.html.14ee0078.js"><link rel="prefetch" href="/front-end-lab/assets/webpack.html.260b310c.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.75d084b5.js"><link rel="prefetch" href="/front-end-lab/assets/theory.html.22272636.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.f1791b22.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.1e2fa0a1.js"><link rel="prefetch" href="/front-end-lab/assets/libs.html.f9cc5d37.js"><link rel="prefetch" href="/front-end-lab/assets/mini-program.html.2d329abf.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.d13fa671.js"><link rel="prefetch" href="/front-end-lab/assets/react.html.ac39f89d.js"><link rel="prefetch" href="/front-end-lab/assets/typescript.html.e91b5fe8.js"><link rel="prefetch" href="/front-end-lab/assets/vue.html.20ecf664.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.31930719.js"><link rel="prefetch" href="/front-end-lab/assets/js.html.11f7a0c4.js"><link rel="prefetch" href="/front-end-lab/assets/404.html.5307af31.js"><link rel="prefetch" href="/front-end-lab/assets/404.9de9fb53.js"><link rel="prefetch" href="/front-end-lab/assets/Layout.f1d6f6f4.js"><link rel="prefetch" href="/front-end-lab/assets/hide-outbound.d7dc1fa7.js"><link rel="prefetch" href="/front-end-lab/assets/index.0e8935cb.js">
    <link rel="stylesheet" href="/front-end-lab/assets/style.75a6fca5.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="切换侧边栏" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/front-end-lab/" class=""><!----><span class="site-name">Web 实验室</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/front-end-lab/develop/" class="" aria-label="Web 开发"><!--[--><!--]--> Web 开发 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/front-end-lab/topic/" class="router-link-active" aria-label="技术要点"><!--[--><!--]--> 技术要点 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Homepage"><!--[--><!--]--> Anran758&#39;s Homepage <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/blog/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Blog"><!--[--><!--]--> Anran758&#39;s Blog <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/anran758/front-end-lab" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="切换夜间模式"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="Search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/front-end-lab/develop/" class="" aria-label="Web 开发"><!--[--><!--]--> Web 开发 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/front-end-lab/topic/" class="router-link-active" aria-label="技术要点"><!--[--><!--]--> 技术要点 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Homepage"><!--[--><!--]--> Anran758&#39;s Homepage <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/blog/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Blog"><!--[--><!--]--> Anran758&#39;s Blog <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/anran758/front-end-lab" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">Web 技术栈 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/front-end-lab/topic/html.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/css.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/js.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/nodejs.html" class="sidebar-item" aria-label="Node.js (服务端开发)"><!--[--><!--]--> Node.js (服务端开发) <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">开发框架与工具 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/front-end-lab/topic/react.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="Vue.js"><!--[--><!--]--> Vue.js <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/vue.html#生命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="生命周期"><!--[--><!--]--> 生命周期 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/vue.html#列举-vue-的生命周期以及它们的应用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="列举 Vue 的生命周期以及它们的应用场景"><!--[--><!--]--> 列举 Vue 的生命周期以及它们的应用场景 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#父组件和子组件生命周期钩子执行顺序是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="父组件和子组件生命周期钩子执行顺序是什么？"><!--[--><!--]--> 父组件和子组件生命周期钩子执行顺序是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#dom-渲染在-vue-的哪个生命周期就已经完成" class="router-link-active router-link-exact-active sidebar-item" aria-label="DOM 渲染在 Vue 的哪个生命周期就已经完成"><!--[--><!--]--> DOM 渲染在 Vue 的哪个生命周期就已经完成 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#应该在哪个生命周期中请求数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="应该在哪个生命周期中请求数据？"><!--[--><!--]--> 应该在哪个生命周期中请求数据？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#beforeunmount-一般的用途" class="router-link-active router-link-exact-active sidebar-item" aria-label="beforeUnmount 一般的用途"><!--[--><!--]--> beforeUnmount 一般的用途 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#基础使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="基础使用"><!--[--><!--]--> 基础使用 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/vue.html#组件之间的如何通信" class="router-link-active router-link-exact-active sidebar-item" aria-label="组件之间的如何通信？"><!--[--><!--]--> 组件之间的如何通信？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#computed-的特点是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="computed 的特点是什么？"><!--[--><!--]--> computed 的特点是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#computed-和-watch-的区别和运用的场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="computed 和 watch 的区别和运用的场景？"><!--[--><!--]--> computed 和 watch 的区别和运用的场景？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#组件的-data-为什么要是一个函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="组件的 data 为什么要是一个函数？"><!--[--><!--]--> 组件的 data 为什么要是一个函数？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-是单向数据流吗-怎样理解-vue-的单向数据流" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 是单向数据流吗？怎样理解 Vue 的单向数据流？"><!--[--><!--]--> Vue 是单向数据流吗？怎样理解 Vue 的单向数据流？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#v-if-与-v-show-有什么区别-在什么场景下可以应用" class="router-link-active router-link-exact-active sidebar-item" aria-label="v-if 与 v-show 有什么区别? 在什么场景下可以应用？"><!--[--><!--]--> v-if 与 v-show 有什么区别? 在什么场景下可以应用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#怎么在组件中实现-v-modal" class="router-link-active router-link-exact-active sidebar-item" aria-label="怎么在组件中实现 v-modal"><!--[--><!--]--> 怎么在组件中实现 v-modal <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-的逻辑复用" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 的逻辑复用？"><!--[--><!--]--> Vue 的逻辑复用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#自定义指令如何封装" class="router-link-active router-link-exact-active sidebar-item" aria-label="自定义指令如何封装？"><!--[--><!--]--> 自定义指令如何封装？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#异步组件的使用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="异步组件的使用场景？"><!--[--><!--]--> 异步组件的使用场景？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#keep-alive-的作用是什么-怎么实现的-如何刷新的-它的使用场景是" class="router-link-active router-link-exact-active sidebar-item" aria-label="keep-alive 的作用是什么？怎么实现的？如何刷新的? 它的使用场景是？"><!--[--><!--]--> keep-alive 的作用是什么？怎么实现的？如何刷新的? 它的使用场景是？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-的响应式开发比命令式有什么好处" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 的响应式开发比命令式有什么好处"><!--[--><!--]--> Vue 的响应式开发比命令式有什么好处 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue3-添加了哪些新特性" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue3 添加了哪些新特性?"><!--[--><!--]--> Vue3 添加了哪些新特性? <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#原理解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="原理解析"><!--[--><!--]--> 原理解析 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-的双向绑定原理是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 的双向绑定原理是什么？"><!--[--><!--]--> Vue 的双向绑定原理是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#v-for-遍历模板时为什么要用-key-key-有什么用" class="router-link-active router-link-exact-active sidebar-item" aria-label="v-for 遍历模板时为什么要用 key? key 有什么用？"><!--[--><!--]--> v-for 遍历模板时为什么要用 key? key 有什么用？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-是怎么解析-template-的-template-会变成什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 是怎么解析 template 的? template 会变成什么?"><!--[--><!--]--> Vue 是怎么解析 template 的? template 会变成什么? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#render-和-template-有什么关系" class="router-link-active router-link-exact-active sidebar-item" aria-label="render 和 template 有什么关系？"><!--[--><!--]--> render 和 template 有什么关系？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#什么是虚拟-dom" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是虚拟 DOM？"><!--[--><!--]--> 什么是虚拟 DOM？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vdom-diff-特点" class="router-link-active router-link-exact-active sidebar-item" aria-label="vdom diff 特点"><!--[--><!--]--> vdom diff 特点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vdom-diff-算法的事件复杂度" class="router-link-active router-link-exact-active sidebar-item" aria-label="vdom diff 算法的事件复杂度"><!--[--><!--]--> vdom diff 算法的事件复杂度 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-如何监听-data-的每个属性变化" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 如何监听 data 的每个属性变化？"><!--[--><!--]--> Vue 如何监听 data 的每个属性变化？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-如何监听数组变化" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 如何监听数组变化"><!--[--><!--]--> Vue 如何监听数组变化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-模板引擎如何解析-指令如何处理-如何渲染为-html" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 模板引擎如何解析？指令如何处理？如何渲染为 HTML"><!--[--><!--]--> Vue 模板引擎如何解析？指令如何处理？如何渲染为 HTML <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue3" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue3"><!--[--><!--]--> Vue3 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue2-和-vue3-有什么区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="vue2 和 vue3 有什么区别"><!--[--><!--]--> vue2 和 vue3 有什么区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-中响应式系统的原理是什么-与-vue-2-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3 中响应式系统的原理是什么？与 Vue 2 的区别？"><!--[--><!--]--> Vue 3 中响应式系统的原理是什么？与 Vue 2 的区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#composition-api-的优势是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="Composition API 的优势是什么？"><!--[--><!--]--> Composition API 的优势是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-的-setup-方法中可以做哪些事情" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3 的 setup 方法中可以做哪些事情？"><!--[--><!--]--> Vue 3 的 setup 方法中可以做哪些事情？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#如何用-vue-3-实现依赖注入" class="router-link-active router-link-exact-active sidebar-item" aria-label="如何用 Vue 3 实现依赖注入？"><!--[--><!--]--> 如何用 Vue 3 实现依赖注入？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-中如何使用-teleport-适合哪些场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3 中如何使用 Teleport？适合哪些场景？"><!--[--><!--]--> Vue 3 中如何使用 Teleport？适合哪些场景？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-如何优化大列表渲染性能" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3 如何优化大列表渲染性能？"><!--[--><!--]--> Vue 3 如何优化大列表渲染性能？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#什么是-script-setup-与普通-setup-有何不同" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是 script setup？与普通 setup 有何不同？"><!--[--><!--]--> 什么是 script setup？与普通 setup 有何不同？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-如何实现自定义指令" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3 如何实现自定义指令？"><!--[--><!--]--> Vue 3 如何实现自定义指令？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-项目中如何使用-typescript" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3 项目中如何使用 TypeScript？"><!--[--><!--]--> Vue 3 项目中如何使用 TypeScript？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-中如何实现状态管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3 中如何实现状态管理？"><!--[--><!--]--> Vue 3 中如何实现状态管理？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-项目如何优化性能" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3 项目如何优化性能？"><!--[--><!--]--> Vue 3 项目如何优化性能？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-中如何设计一个可复用的表单组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3 中如何设计一个可复用的表单组件？"><!--[--><!--]--> Vue 3 中如何设计一个可复用的表单组件？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-与其他前端框架-如-react-的优劣对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3 与其他前端框架（如 React）的优劣对比？"><!--[--><!--]--> Vue 3 与其他前端框架（如 React）的优劣对比？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-2-项目迁移到-vue-3-的难点是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 2 项目迁移到 Vue 3 的难点是什么？"><!--[--><!--]--> Vue 2 项目迁移到 Vue 3 的难点是什么？ <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#uni-app" class="router-link-active router-link-exact-active sidebar-item" aria-label="uni-app"><!--[--><!--]--> uni-app <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/vue.html#uni-app-中如何做权限控制-如果在-uniapp-的路由跳转-api-中做权限控制-怎么改写" class="router-link-active router-link-exact-active sidebar-item" aria-label="uni-app 中如何做权限控制，如果在 uniapp 的路由跳转 API 中做权限控制，怎么改写"><!--[--><!--]--> uni-app 中如何做权限控制，如果在 uniapp 的路由跳转 API 中做权限控制，怎么改写 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-router" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue-router"><!--[--><!--]--> Vue-router <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-router-的-hash-模式和-history-模式有什么区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue-router 的 hash 模式和 history 模式有什么区别？"><!--[--><!--]--> Vue-router 的 hash 模式和 history 模式有什么区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-router-的-beforeeach-和-aftereach-一般用法-使用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue router 的 beforeEach 和 afterEach 一般用法/使用场景?"><!--[--><!--]--> Vue router 的 beforeEach 和 afterEach 一般用法/使用场景? <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vuex" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vuex"><!--[--><!--]--> Vuex <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-中的-action-和-mutation-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 中的 action 和 mutation 的区别"><!--[--><!--]--> Vue 中的 action 和 mutation 的区别 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#性能优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-与-react-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 与 React 的区别"><!--[--><!--]--> Vue 与 React 的区别 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/front-end-lab/topic/webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">优化与原理解析 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/front-end-lab/topic/browser.html" class="sidebar-item" aria-label="浏览器工作原理"><!--[--><!--]--> 浏览器工作原理 <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/performance.html" class="sidebar-item" aria-label="应用优化"><!--[--><!--]--> 应用优化 <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/network.html" class="sidebar-item" aria-label="网络原理"><!--[--><!--]--> 网络原理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/front-end-lab/topic/complex.html" class="sidebar-item sidebar-heading" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="vue-js" tabindex="-1"><a class="header-anchor" href="#vue-js" aria-hidden="true">#</a> Vue.js</h1><p><img src="/front-end-lab/assets/vuejs.678c5d67.jpg" alt="vue.js cover"></p><nav class="table-of-contents"><ul><li><a aria-current="page" href="/front-end-lab/topic/vue.html#生命周期" class="router-link-active router-link-exact-active">生命周期</a><ul><li><a aria-current="page" href="/front-end-lab/topic/vue.html#列举-vue-的生命周期以及它们的应用场景" class="router-link-active router-link-exact-active">列举 Vue 的生命周期以及它们的应用场景</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#父组件和子组件生命周期钩子执行顺序是什么" class="router-link-active router-link-exact-active">父组件和子组件生命周期钩子执行顺序是什么？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#dom-渲染在-vue-的哪个生命周期就已经完成" class="router-link-active router-link-exact-active">DOM 渲染在 Vue 的哪个生命周期就已经完成</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#应该在哪个生命周期中请求数据" class="router-link-active router-link-exact-active">应该在哪个生命周期中请求数据？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#beforeunmount-一般的用途" class="router-link-active router-link-exact-active">beforeUnmount 一般的用途</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#基础使用" class="router-link-active router-link-exact-active">基础使用</a><ul><li><a aria-current="page" href="/front-end-lab/topic/vue.html#组件之间的如何通信" class="router-link-active router-link-exact-active">组件之间的如何通信？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#computed-的特点是什么" class="router-link-active router-link-exact-active">computed 的特点是什么？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#computed-和-watch-的区别和运用的场景" class="router-link-active router-link-exact-active">computed 和 watch 的区别和运用的场景？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#组件的-data-为什么要是一个函数" class="router-link-active router-link-exact-active">组件的 data 为什么要是一个函数？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-是单向数据流吗-怎样理解-vue-的单向数据流" class="router-link-active router-link-exact-active">Vue 是单向数据流吗？怎样理解 Vue 的单向数据流？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#v-if-与-v-show-有什么区别-在什么场景下可以应用" class="router-link-active router-link-exact-active">v-if 与 v-show 有什么区别? 在什么场景下可以应用？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#怎么在组件中实现-v-modal" class="router-link-active router-link-exact-active">怎么在组件中实现 v-modal</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-的逻辑复用" class="router-link-active router-link-exact-active">Vue 的逻辑复用？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#自定义指令如何封装" class="router-link-active router-link-exact-active">自定义指令如何封装？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#异步组件的使用场景" class="router-link-active router-link-exact-active">异步组件的使用场景？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#keep-alive-的作用是什么-怎么实现的-如何刷新的-它的使用场景是" class="router-link-active router-link-exact-active">keep-alive 的作用是什么？怎么实现的？如何刷新的? 它的使用场景是？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-的响应式开发比命令式有什么好处" class="router-link-active router-link-exact-active">Vue 的响应式开发比命令式有什么好处</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue3-添加了哪些新特性" class="router-link-active router-link-exact-active">Vue3 添加了哪些新特性?</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#原理解析" class="router-link-active router-link-exact-active">原理解析</a><ul><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-的双向绑定原理是什么" class="router-link-active router-link-exact-active">Vue 的双向绑定原理是什么？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#v-for-遍历模板时为什么要用-key-key-有什么用" class="router-link-active router-link-exact-active">v-for 遍历模板时为什么要用 key? key 有什么用？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-是怎么解析-template-的-template-会变成什么" class="router-link-active router-link-exact-active">Vue 是怎么解析 template 的? template 会变成什么?</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#render-和-template-有什么关系" class="router-link-active router-link-exact-active">render 和 template 有什么关系？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#什么是虚拟-dom" class="router-link-active router-link-exact-active">什么是虚拟 DOM？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vdom-diff-特点" class="router-link-active router-link-exact-active">vdom diff 特点</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vdom-diff-算法的事件复杂度" class="router-link-active router-link-exact-active">vdom diff 算法的事件复杂度</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-如何监听-data-的每个属性变化" class="router-link-active router-link-exact-active">Vue 如何监听 data 的每个属性变化？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-如何监听数组变化" class="router-link-active router-link-exact-active">Vue 如何监听数组变化</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-模板引擎如何解析-指令如何处理-如何渲染为-html" class="router-link-active router-link-exact-active">Vue 模板引擎如何解析？指令如何处理？如何渲染为 HTML</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue3" class="router-link-active router-link-exact-active">Vue3</a><ul><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue2-和-vue3-有什么区别" class="router-link-active router-link-exact-active">vue2 和 vue3 有什么区别</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-中响应式系统的原理是什么-与-vue-2-的区别" class="router-link-active router-link-exact-active">Vue 3 中响应式系统的原理是什么？与 Vue 2 的区别？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#composition-api-的优势是什么" class="router-link-active router-link-exact-active">Composition API 的优势是什么？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-的-setup-方法中可以做哪些事情" class="router-link-active router-link-exact-active">Vue 3 的 setup 方法中可以做哪些事情？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#如何用-vue-3-实现依赖注入" class="router-link-active router-link-exact-active">如何用 Vue 3 实现依赖注入？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-中如何使用-teleport-适合哪些场景" class="router-link-active router-link-exact-active">Vue 3 中如何使用 Teleport？适合哪些场景？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-如何优化大列表渲染性能" class="router-link-active router-link-exact-active">Vue 3 如何优化大列表渲染性能？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#什么是-script-setup-与普通-setup-有何不同" class="router-link-active router-link-exact-active">什么是 script setup？与普通 setup 有何不同？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-如何实现自定义指令" class="router-link-active router-link-exact-active">Vue 3 如何实现自定义指令？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-项目中如何使用-typescript" class="router-link-active router-link-exact-active">Vue 3 项目中如何使用 TypeScript？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-中如何实现状态管理" class="router-link-active router-link-exact-active">Vue 3 中如何实现状态管理？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-项目如何优化性能" class="router-link-active router-link-exact-active">Vue 3 项目如何优化性能？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-中如何设计一个可复用的表单组件" class="router-link-active router-link-exact-active">Vue 3 中如何设计一个可复用的表单组件？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-3-与其他前端框架-如-react-的优劣对比" class="router-link-active router-link-exact-active">Vue 3 与其他前端框架（如 React）的优劣对比？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-2-项目迁移到-vue-3-的难点是什么" class="router-link-active router-link-exact-active">Vue 2 项目迁移到 Vue 3 的难点是什么？</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#uni-app" class="router-link-active router-link-exact-active">uni-app</a><ul><li><a aria-current="page" href="/front-end-lab/topic/vue.html#uni-app-中如何做权限控制-如果在-uniapp-的路由跳转-api-中做权限控制-怎么改写" class="router-link-active router-link-exact-active">uni-app 中如何做权限控制，如果在 uniapp 的路由跳转 API 中做权限控制，怎么改写</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-router" class="router-link-active router-link-exact-active">Vue-router</a><ul><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-router-的-hash-模式和-history-模式有什么区别" class="router-link-active router-link-exact-active">Vue-router 的 hash 模式和 history 模式有什么区别？</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-router-的-beforeeach-和-aftereach-一般用法-使用场景" class="router-link-active router-link-exact-active">Vue router 的 beforeEach 和 afterEach 一般用法/使用场景?</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vuex" class="router-link-active router-link-exact-active">Vuex</a><ul><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-中的-action-和-mutation-的区别" class="router-link-active router-link-exact-active">Vue 中的 action 和 mutation 的区别</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#性能优化" class="router-link-active router-link-exact-active">性能优化</a></li><li><a aria-current="page" href="/front-end-lab/topic/vue.html#vue-与-react-的区别" class="router-link-active router-link-exact-active">Vue 与 React 的区别</a></li></ul></nav><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h2><h3 id="列举-vue-的生命周期以及它们的应用场景" tabindex="-1"><a class="header-anchor" href="#列举-vue-的生命周期以及它们的应用场景" aria-hidden="true">#</a> 列举 Vue 的生命周期以及它们的应用场景</h3><p>Vue 的生命周期可以分为<strong>挂载阶段</strong>、<strong>更新阶段</strong>、<strong>销毁阶段</strong>三大阶段。</p><ul><li><strong>挂载阶段</strong>: <code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code>。</li><li><strong>更新阶段</strong>: <code>beforeUpdate</code>、<code>updated</code>。</li><li><strong>销毁阶段</strong>: <code>beforeUnmount</code>、<code>unmounted</code>。</li></ul><p><img src="/front-end-lab/assets/vue-lifecycle-v3.ca63c265.svg" alt="Vue 生命周期"></p><table><thead><tr><th>生命周期</th><th>描述</th><th>使用场景</th></tr></thead><tbody><tr><td>beforeCreate</td><td>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。此处无法修改 Vue 实例的 <code>data</code> 和 <code>methods</code></td><td>由于触发的时机较早，可以处理 window.title 等外部逻辑。</td></tr><tr><td>create</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，<code>vm.$el</code> 还不可用</td><td>可以做一些初始化工作</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用。</td><td>略</td></tr><tr><td>mounted</td><td>实例被挂载后调用，此时可以访问 <code>vm.$el</code>、可以操作 DOM</td><td>fetch data、DOM 操作等</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td><td>适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</td></tr><tr><td>updated</td><td>组件数据更新之后</td><td>现在可以执行依赖于 DOM 的操作</td></tr><tr><td>beforeUnmount</td><td>组件销毁前调用</td><td>解除自定义事件、消除定时器、解绑自定义的 DOM 事件监听器</td></tr><tr><td>unmounted</td><td>组件销毁后调用, 此时实例仍然是完全正常的</td><td>略</td></tr></tbody></table><h3 id="父组件和子组件生命周期钩子执行顺序是什么" tabindex="-1"><a class="header-anchor" href="#父组件和子组件生命周期钩子执行顺序是什么" aria-hidden="true">#</a> 父组件和子组件生命周期钩子执行顺序是什么？</h3><p><strong>渲染阶段</strong>：</p><div class="language-diff ext-diff line-numbers-mode"><pre class="language-diff"><code>+ 父 beforeCreate
+ 父 created
+ 父 beforeMount

- 子 beforeCreat
- 子 created
- 子 beforeMount
- 子 mounted

+ 父 mounted
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>更新阶段</strong>：</p><div class="language-diff ext-diff line-numbers-mode"><pre class="language-diff"><code>+ 父 beforeUpdate

- 子 beforeUpdate
- 子 updated

+ 父 updated
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>销毁阶段</strong>：</p><div class="language-diff ext-diff line-numbers-mode"><pre class="language-diff"><code>+ 父 beforeUnmount

- 子 beforeUnmount
- 子 unmounted

+ 父 unmounted
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="dom-渲染在-vue-的哪个生命周期就已经完成" tabindex="-1"><a class="header-anchor" href="#dom-渲染在-vue-的哪个生命周期就已经完成" aria-hidden="true">#</a> DOM 渲染在 Vue 的哪个生命周期就已经完成</h3><p><code>mounted</code> 阶段完成挂载。</p><h3 id="应该在哪个生命周期中请求数据" tabindex="-1"><a class="header-anchor" href="#应该在哪个生命周期中请求数据" aria-hidden="true">#</a> 应该在哪个生命周期中请求数据？</h3><p>放在 <code>mounted</code>。由于 js 是单线程，在 ajax 中异步获取到的数据 Vue 并不能立即赋值到 data 中，同时还会使逻辑变得更加混乱。</p><h3 id="beforeunmount-一般的用途" tabindex="-1"><a class="header-anchor" href="#beforeunmount-一般的用途" aria-hidden="true">#</a> beforeUnmount 一般的用途</h3><ul><li>解除自定义事件</li><li>消除定时器</li><li>解绑自定义的 DOM 事件监听器</li></ul><h2 id="基础使用" tabindex="-1"><a class="header-anchor" href="#基础使用" aria-hidden="true">#</a> 基础使用</h2><h3 id="组件之间的如何通信" tabindex="-1"><a class="header-anchor" href="#组件之间的如何通信" aria-hidden="true">#</a> 组件之间的如何通信？</h3><ul><li>父组件给子组件传入 <code>props</code>并监听子组件对应的事件，子组件通过 <code>emit</code> 触发事件。</li><li>event-bus</li><li>Vuex 等状态管理器</li></ul><h3 id="computed-的特点是什么" tabindex="-1"><a class="header-anchor" href="#computed-的特点是什么" aria-hidden="true">#</a> computed 的特点是什么？</h3><p>计算的值会被缓存，若 data 不会重新计算，进而提升 Vue 的性能。</p><h3 id="computed-和-watch-的区别和运用的场景" tabindex="-1"><a class="header-anchor" href="#computed-和-watch-的区别和运用的场景" aria-hidden="true">#</a> computed 和 watch 的区别和运用的场景？</h3><ul><li><code>computed</code>: <code>computed</code> 是计算属性，计算的值会被缓存，若 <code>data</code> 没有改变则不会重新计算。</li><li><code>watch</code>: 每当监听的数据变化时都会执行回调进行后续操作</li></ul><p><strong>运用场景</strong>：</p><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><h3 id="组件的-data-为什么要是一个函数" tabindex="-1"><a class="header-anchor" href="#组件的-data-为什么要是一个函数" aria-hidden="true">#</a> 组件的 data 为什么要是一个函数？</h3><p>由于 JavaScript 对象引用的特性，直接使用对象的话，组件实例化后数据将不能保持独立，组件 A 修改了数据后，组件 B 也会跟着被修改。</p><p>因此需要使用函数，在函数内返回一个新的对象，确保每个实例后的组件的数据是彼此独立的。</p><h3 id="vue-是单向数据流吗-怎样理解-vue-的单向数据流" tabindex="-1"><a class="header-anchor" href="#vue-是单向数据流吗-怎样理解-vue-的单向数据流" aria-hidden="true">#</a> Vue 是单向数据流吗？怎样理解 Vue 的单向数据流？</h3><p>是单向数据流。</p><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样做的意图是: 防止从子组件意外改变父级组件的状态，从而导致应用的数据流向变得难以理解。</p><p>在每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 <code>$emit</code> 派发一个自定义事件，父组件接收到事件后，由父组件修改。</p><h3 id="v-if-与-v-show-有什么区别-在什么场景下可以应用" tabindex="-1"><a class="header-anchor" href="#v-if-与-v-show-有什么区别-在什么场景下可以应用" aria-hidden="true">#</a> v-if 与 v-show 有什么区别? 在什么场景下可以应用？</h3><ul><li>使用 <code>v-show</code> 的节点会直接渲染到 DOM 树中，它的显示与隐藏是通过 css 属性 <code>display</code> 来控制的。</li><li>使用 <code>v-if</code> 的节点默认不会直接渲染到 DOM 树中，它的显示与隐藏是根据 <code>v-if</code> 的值判断是否将节点渲染到 DOM 树中。</li><li>合适的使用场景: 需要频繁切换展示或隐藏的状态可使用 <code>v-show</code>；仅少数情况会切换状态可使用 <code>v-if</code>。</li></ul><p>主要取决于元素是否会多次渲染，<code>v-if</code> 决定节点是否渲染；<code>v-show</code> 会渲染节点，但会通过 <code>display</code> 控制是否展示。</p><p>如果仅需渲染一次的话可以使用 <code>v-if</code>。反之，如果需要频繁渲染的话可以使用 <code>v-show</code> 仅展示显隐。</p><h3 id="怎么在组件中实现-v-modal" tabindex="-1"><a class="header-anchor" href="#怎么在组件中实现-v-modal" aria-hidden="true">#</a> 怎么在组件中实现 v-modal</h3><p><code>v-model</code> 默认会利用组件中名为 <code>value</code> 的 <code>prop</code> 和监听名为 <code>input</code> 的事件 (<code>event</code>) 完成双向绑定。原理是: 当触发 <code>input</code> 事件时，会将 <code>input</code> 函数接收的值赋值给 <code>value</code>。</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code>&lt;input v-model=&quot;name&quot; /&gt;

&lt;!-- 等同于 --&gt;
&lt;input :value=&quot;name&quot; @input=&quot;name = $event.target.value&quot; /&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>自定义组件可以设置 <code>model</code> 来改变 <code>v-model</code> 绑定的属性和方法。例如封装一个 <code>checkbox</code> 组件, 它被选中的属性应该是 <code>checked</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Vue.component(&quot;base-checkbox&quot;, {
  model: {
    prop: &quot;checked&quot;,
    event: &quot;change&quot;,
  },
  props: {
    checked: Boolean,
  },
  template: `
    &lt;input
      type=&quot;checkbox&quot;
      v-bind:checked=&quot;checked&quot;
      v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;
    &gt;
  `,
});
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="vue-的逻辑复用" tabindex="-1"><a class="header-anchor" href="#vue-的逻辑复用" aria-hidden="true">#</a> Vue 的逻辑复用？</h3><p><strong>Vue 2</strong></p><ol><li>Mixin：可以定义一些共享的方法、计算属性、生命周期钩子等，然后将它们混入到需要的组件中。这样可以避免重复编写相同的逻辑。</li><li>自定义指令：自定义指令允许在 DOM 元素上添加一些特定行为，可以用于复用一些 DOM 操作的逻辑。</li><li>自定义组件：将通用的逻辑抽象到全局组件中</li><li>插件：Vue 插件可以为 Vue 应用添加全局功能。你可以将一些常用的功能封装成插件，然后在 Vue 实例中通过 Vue.use() 方法来使用它们。</li></ol><p><strong>Vue 3</strong></p><ol><li>Composition API 允许按功能组织组件逻辑，并且在不同组件之间共享和复用。</li></ol><h3 id="自定义指令如何封装" tabindex="-1"><a class="header-anchor" href="#自定义指令如何封装" aria-hidden="true">#</a> 自定义指令如何封装？</h3><p>通过 <code>Vue.directive</code> 方法来定义自定义指令。自定义指令可以用于在 DOM 元素上添加一些特殊行为，比如改变样式、添加事件监听器、操作 DOM 等。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>// 注册一个全局自定义指令 `v-focus`
Vue.directive(&#39;focus&#39;, {
  // 当被绑定的元素插入到 DOM 中时...
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})

// 使用示例
&lt;input v-focus&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="异步组件的使用场景" tabindex="-1"><a class="header-anchor" href="#异步组件的使用场景" aria-hidden="true">#</a> 异步组件的使用场景？</h3><ol><li><strong>加载大组件</strong>：使用异步加载可以减少应用的初始加载时间。这些大组件通常包括复杂的功能或包含大量的子组件和依赖，它们的按需加载可以有效优化资源使用和提升性能。</li><li><strong>路由级异步加载</strong>：在 Vue 的单页应用（SPA）中，可以将不同的页面（路由）设定为异步组件。这样，在应用路由切换时，相关页面的组件才会加载，进一步提升了页面加载速度和用户的交互体验。</li></ol><h3 id="keep-alive-的作用是什么-怎么实现的-如何刷新的-它的使用场景是" tabindex="-1"><a class="header-anchor" href="#keep-alive-的作用是什么-怎么实现的-如何刷新的-它的使用场景是" aria-hidden="true">#</a> keep-alive 的作用是什么？怎么实现的？如何刷新的? 它的使用场景是？</h3><p><code>keep-alive</code> 是一个抽象组件，用于缓存非活动的组件实例而不是销毁它们。主要用于提高应用性能，尤其是在频繁切换组件时，可以避免重复渲染带来的性能开销。</p><p>它通过钩子函数 <code>activated</code> 和 <code>deactivated</code> 来管理组件的显示与隐藏。当需要刷新缓存的组件时，可以通过更改组件的 <code>key</code> 或直接清理 <code>keep-alive</code> 的缓存来实现。</p><div class="language-Vue ext-Vue line-numbers-mode"><pre class="language-Vue"><code>&lt;keep-alive&gt;
  &lt;component :is=&quot;currentComponent&quot; :key=&quot;componentKey&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>使用场景：</p><p>假设我们有一个电商应用，用户频繁切换查看不同产品的详情页。如果每次切换都重新加载组件，会消耗大量资源并降低用户体验。使用 <code>keep-alive</code> 可以保持用户的滚动位置和之前的交互状态，当用户返回之前查看的页面时，页面可以迅速加载且状态一致，从而提高了用户体验和应用的性能。</p><h3 id="vue-的响应式开发比命令式有什么好处" tabindex="-1"><a class="header-anchor" href="#vue-的响应式开发比命令式有什么好处" aria-hidden="true">#</a> Vue 的响应式开发比命令式有什么好处</h3><p>Vue 的响应式编程模型相比于命令式编程的主要好处包括：</p><ol><li><strong>代码更简洁</strong>：自动数据绑定减少了手动更新 UI 的代码。</li><li><strong>提高开发效率</strong>：开发者可以专注于业务逻辑，而不是如何操作 DOM。</li><li><strong>维护更容易</strong>：集中的数据管理和自动化的 UI 更新简化了维护工作。</li><li><strong>数据和视图一致性</strong>：确保数据的变化即时反映到 UI 上，减少错误和不一致的情况。</li></ol><h3 id="vue3-添加了哪些新特性" tabindex="-1"><a class="header-anchor" href="#vue3-添加了哪些新特性" aria-hidden="true">#</a> Vue3 添加了哪些新特性?</h3><p>主要的新特性包括：</p><ol><li><strong>Composition API</strong>：提供了一种新的方式来组织和重用组件逻辑，有助于更好地利用 TypeScript 和提高代码的可维护性。</li><li><strong>性能提升</strong>：通过重写虚拟 DOM 和使用 Proxy 改进响应性系统，Vue 3 在渲染和更新速度上都有显著提升。</li><li><strong>更好的 TypeScript 支持</strong>：Vue 3 从设计之初就更好地支持 TypeScript，为使用 TypeScript 的项目带来了更强大的类型推导和错误检测能力。</li><li><strong>新的内置组件</strong>：如 Teleport 和 Suspense，提供了新的模式来处理模板渲染和异步组件。</li><li><strong>多根组件</strong>：Vue 3 允许组件有多个根节点，简化了组件的设计。</li><li><strong>改进的响应性系统</strong>：使用 ES6 的 Proxy 特性，提供更有效的响应性跟踪和更好的性能。</li></ol><h2 id="原理解析" tabindex="-1"><a class="header-anchor" href="#原理解析" aria-hidden="true">#</a> 原理解析</h2><h3 id="vue-的双向绑定原理是什么" tabindex="-1"><a class="header-anchor" href="#vue-的双向绑定原理是什么" aria-hidden="true">#</a> Vue 的双向绑定原理是什么？</h3><p>Vue.js 的双向绑定机制在 Vue 2.x 中通过 <code>Object.defineProperty</code> 实现，而在 Vue 3.x 中则是通过 <code>Proxy</code>（）来对数据对象进行劫持。</p><p><strong>Vue 2.x 双向绑定原理</strong></p><p>在 Vue 2.x 中，双向绑定的核心是 <strong>响应式系统</strong>。其基本步骤如下：</p><ol><li><p><strong>数据劫持</strong>：Vue 通过 <code>Object.defineProperty</code> 函数对组件的数据对象进行劫持（即使数据属性变得可观察）。对数据对象的每一个属性，Vue 会定义对应的 getter 和 setter。</p></li><li><p><strong>依赖收集</strong>：</p><ul><li>当渲染函数或计算属性等被执行时，它们会访问响应式数据的属性，此时属性的 getter 函数被调用。</li><li>Getter 函数负责收集依赖，即识别哪些组件或计算属性依赖于这个数据属性（通过依赖管理器，通常是一个 Watcher 实例）。</li></ul></li><li><p><strong>派发更新</strong>：</p><ul><li>当响应式数据的属性值被修改时，其 setter 函数被调用。</li><li>Setter 会通知所有依赖于该属性的组件或计算属性，导致它们重新评估或重新渲染。</li></ul></li><li><p><strong>视图更新</strong>：组件重新渲染，将新的数据值反映到 DOM 中，完成数据到视图的更新。</p></li></ol><p><strong>Vue 3.x 双向绑定原理</strong></p><p>Vue 3.x 改进了响应式系统，采用了 ES6 的 <code>Proxy</code> 来替代 <code>Object.defineProperty</code>，这带来了几个优势，如性能提升和更好的语言特性支持。其原理如下：</p><ol><li><p><strong>使用 Proxy</strong>：Vue 3 使用 <code>Proxy</code> 对组件的根数据对象进行劫持，可以拦截更多的操作，如属性添加、删除等，并且不需要预先定义属性。</p></li><li><p><strong>响应式转换</strong>：当数据对象通过 Proxy 被访问或修改时，Proxy 的处理函数（handler）会对应地调用 getter 和 setter。</p><ul><li><strong>Getter</strong>：执行依赖收集，类似 Vue 2.x。</li><li><strong>Setter</strong>：执行派发更新，通知变更。</li></ul></li><li><p><strong>更细致的变更检测</strong>：因为 Proxy 可以监控到更多类型的变化，Vue 3 的响应式系统可以更灵活地处理数组和嵌套对象的更新，从而提高性能和响应性。</p></li></ol><p><strong>结合 v-model 实现双向绑定</strong></p><p>在具体实现双向绑定时，<code>v-model</code> 指令是一个常见的工具，它实际上是一个语法糖，结合了输入元素的 <code>value</code> 属性和 <code>input</code> 事件。例如，在一个输入框中使用 <code>v-model</code>：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code>&lt;input v-model=&quot;message&quot;&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这等同于：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code>&lt;input :value=&quot;message&quot; @input=&quot;message = $event.target.value&quot;&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这样，数据的变化会实时反映在输入框中，输入框的变化也会实时更新数据，从而实现双向绑定。</p><h3 id="v-for-遍历模板时为什么要用-key-key-有什么用" tabindex="-1"><a class="header-anchor" href="#v-for-遍历模板时为什么要用-key-key-有什么用" aria-hidden="true">#</a> v-for 遍历模板时为什么要用 key? key 有什么用？</h3><p>必须要用 key。因为当列表刷新时，底层的虚拟 DOM 会使用 diff 算法来对比新旧 DOM 树的变化。</p><p>它首先是比对同一层级的 <code>tag</code> 和 <code>key</code> 来判断是否是同一个节点(sameNode)；若同一个层级的列表项都设有唯一的 key 的话，那就可以避免重复渲染的问题，从而提升渲染性能。</p><h3 id="vue-是怎么解析-template-的-template-会变成什么" tabindex="-1"><a class="header-anchor" href="#vue-是怎么解析-template-的-template-会变成什么" aria-hidden="true">#</a> Vue 是怎么解析 template 的? template 会变成什么?</h3><p>模板解析的步骤简单的来说：</p><ol><li><p><strong>解析</strong>： Vue 通过一个解析器（parser）读取 <code>template</code> 字符串，解析里面的 HTML 结构、指令、插值表达式（如 <code>{{ message }}</code>）和绑定的属性。</p></li><li><p><strong>优化</strong>： Vue 的编译器会对解析后的抽象语法树（AST）进行优化，识别静态根节点，这样在后续的 diff 和重渲染操作中，可以跳过静态节点，提升性能。</p></li><li><p><strong>代码生成</strong>： 编译器将优化后的 AST 转换为 JavaScript 渲染函数的代码。这个函数是实际驱动视图更新的部分。</p></li></ol><p>模板（<code>template</code>）最终会被编译成一个渲染函数（render function）。这个函数是 JavaScript 代码，用来高效地构建和更新虚拟 DOM（Virtual DOM）。当数据发生变化时，Vue 会重新执行渲染函数来更新虚拟 DOM，接着通过 DOM diff 算法来高效更新实际的 DOM。</p><p>例如：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code>&lt;div id=&quot;app&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
&lt;/div&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>经过编译后，对应的渲染函数可能类似于：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function render() {
  with(this) {
    return _c(&#39;div&#39;, {attrs: {&quot;id&quot;:&quot;app&quot;}}, [
      _c(&#39;p&#39;, [_v(_s(message))])
    ])
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><hr><h3 id="render-和-template-有什么关系" tabindex="-1"><a class="header-anchor" href="#render-和-template-有什么关系" aria-hidden="true">#</a> render 和 template 有什么关系？</h3><p>它们都用于生成组件的 HTML 输出，只是使用方式有差异。</p><ul><li>使用 <code>template</code>: 这是一种声明式语法，使用起来有直接编写 HTML 风格，看上去更简单直观。</li><li>使用 <code>render</code> 函数: 这种一个纯 JavaScript 函数，它可以让开发者通过编程的方式生成虚拟 DOM，从而控制组件的输出。<code>render</code> 函数相比模板语法会更加灵活。</li></ul><p><code>template</code> 模板语法只是 <code>Vue</code> 提供的语法糖，最终也会通过解析器(parser)转换为 <code>render</code> 函数。因此实际使用时会根据场景去选择使用。</p><hr><h3 id="什么是虚拟-dom" tabindex="-1"><a class="header-anchor" href="#什么是虚拟-dom" aria-hidden="true">#</a> 什么是虚拟 DOM？</h3><p>虚拟 DOM 主要是指 <code>vdom</code>, 它用 js 生成 DOM 树来模拟 DOM 结构，计算出最小的变更来操作 dom。</p><p>由于真实 DOM 的操作会非常耗费性能，因此 Vue 引入了虚拟 DOM 来检查对 DOM 的操作。引入虚拟 DOM 后，开发方式也发生了改变。以前需要手动操作 DOM，现在只需要关心数据的变化，由数据驱动视图。</p><p>虚拟 DOM 计算最小的变更是通过 <code>diff</code> 算法来实现的，它也是 <code>vdom</code> 中最核心、最关键的部分。我们常说的 <code>vdom diff</code> 其实就是 <code>diff</code> 新旧树的变化。</p><h3 id="vdom-diff-特点" tabindex="-1"><a class="header-anchor" href="#vdom-diff-特点" aria-hidden="true">#</a> vdom diff 特点</h3><ul><li>vdom diff 只 diff 同一层，不跨级比较。</li><li>tag 不相同，则直接丢掉重建，不再深度比较。</li><li>tag 和 key，两者都相同，则认为是相同节点，不再深度比较。</li></ul><h3 id="vdom-diff-算法的事件复杂度" tabindex="-1"><a class="header-anchor" href="#vdom-diff-算法的事件复杂度" aria-hidden="true">#</a> vdom diff 算法的事件复杂度</h3><p>在 <code>O(n^3)</code> 的基础上使用了同层比较策略，因此优化为 <code>O(n)</code>.</p><h3 id="vue-如何监听-data-的每个属性变化" tabindex="-1"><a class="header-anchor" href="#vue-如何监听-data-的每个属性变化" aria-hidden="true">#</a> Vue 如何监听 data 的每个属性变化？</h3><p>Vue.js 提供了 <code>$watch</code> 方法来监听数据对象的变化，可以用它来监听每个属性的变化。</p><p>Vue.js 实现数据双向绑定的原理是通过 <code>Object.defineProperty()</code> 方法对数据对象进行拦截，将每个属性都转换为 <code>getter/setter</code>，在拦截器中进行依赖收集和派发更新的操作。$watch 实际上是对每个属性的 <code>getter/setter</code> 进行了包装，将回调函数作为其监听器。</p><h3 id="vue-如何监听数组变化" tabindex="-1"><a class="header-anchor" href="#vue-如何监听数组变化" aria-hidden="true">#</a> Vue 如何监听数组变化</h3><p><code>Object.defineProperty</code> 只能对属性进行数据劫持，不能监听数组变化，需要重新原型，重写 push/pop 等方法实现监听：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array&lt;any&gt;) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      observe(items[i])  // observe 功能为监测数据的变化
    }
  }

  /**
   * 对属性进行递归遍历
   */
  let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>在 Vue3 中使用了 <code>Proxy</code> 代替 <code>Object.defineProperty</code>，<code>Proxy</code> 可以原生支持监听数组变化。</p><h3 id="vue-模板引擎如何解析-指令如何处理-如何渲染为-html" tabindex="-1"><a class="header-anchor" href="#vue-模板引擎如何解析-指令如何处理-如何渲染为-html" aria-hidden="true">#</a> Vue 模板引擎如何解析？指令如何处理？如何渲染为 HTML</h3><ul><li>在开发环境下使用 webpack 的 Vue-loader 编译模板</li><li>先将模板编译为 <code>render</code> 函数，执行 <code>render</code> 函数会返回 <code>vnoe</code></li><li>基于 <code>vnode</code> 再执行 patch 和 diff</li></ul><h2 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3" aria-hidden="true">#</a> Vue3</h2><h3 id="vue2-和-vue3-有什么区别" tabindex="-1"><a class="header-anchor" href="#vue2-和-vue3-有什么区别" aria-hidden="true">#</a> vue2 和 vue3 有什么区别</h3><p>Vue 2 和 Vue 3 的区别在于：</p><ul><li>性能优化（Proxy 替代 Object.defineProperty）</li><li>引入 Composition API 提升逻辑复用性</li><li>增强模板功能（支持 Fragment 和 Teleport）</li><li>原生支持 TypeScript。</li><li>通过 Tree-Shaking 使得未使用的功能不会打包，提高了性能，得到了更小的打包体积。</li></ul><h3 id="vue-3-中响应式系统的原理是什么-与-vue-2-的区别" tabindex="-1"><a class="header-anchor" href="#vue-3-中响应式系统的原理是什么-与-vue-2-的区别" aria-hidden="true">#</a> Vue 3 中响应式系统的原理是什么？与 Vue 2 的区别？</h3><ul><li>Vue 3 使用 <code>Proxy</code> 替代 <code>Object.defineProperty</code> 实现响应式，解决了以下问题： <ul><li>支持数组和对象的动态属性。</li><li>性能更高，避免深度遍历。</li><li>更方便实现只读（<code>readonly</code>）和浅层响应（<code>shallowReactive</code>）。</li></ul></li></ul><hr><h3 id="composition-api-的优势是什么" tabindex="-1"><a class="header-anchor" href="#composition-api-的优势是什么" aria-hidden="true">#</a> Composition API 的优势是什么？</h3><ul><li>灵活性高，逻辑更清晰。</li><li>逻辑复用更简单，适合提取通用功能为自定义 Hook。</li><li>解决 Options API 中逻辑分散、复杂组件难以维护的问题。</li></ul><hr><h3 id="vue-3-的-setup-方法中可以做哪些事情" tabindex="-1"><a class="header-anchor" href="#vue-3-的-setup-方法中可以做哪些事情" aria-hidden="true">#</a> Vue 3 的 <code>setup</code> 方法中可以做哪些事情？</h3><ul><li>定义响应式数据（<code>ref</code>、<code>reactive</code>）。</li><li>使用生命周期钩子（<code>onMounted</code>、<code>onUpdated</code> 等）。</li><li>引入并使用 <code>props</code> 和 <code>context</code>（包含 <code>slots</code>、<code>emit</code>）。</li><li>返回绑定到模板的数据和方法。</li></ul><hr><h3 id="如何用-vue-3-实现依赖注入" tabindex="-1"><a class="header-anchor" href="#如何用-vue-3-实现依赖注入" aria-hidden="true">#</a> 如何用 Vue 3 实现依赖注入？</h3><ul><li>使用 <code>provide</code> 和 <code>inject</code>：<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>// 父组件
import { provide } from &#39;vue&#39;;
provide(&#39;key&#39;, value);

// 子组件
import { inject } from &#39;vue&#39;;
const value = inject(&#39;key&#39;);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li>常用于跨层级组件通信。</li></ul><hr><h3 id="vue-3-中如何使用-teleport-适合哪些场景" tabindex="-1"><a class="header-anchor" href="#vue-3-中如何使用-teleport-适合哪些场景" aria-hidden="true">#</a> Vue 3 中如何使用 Teleport？适合哪些场景？</h3><ul><li>Teleport 允许将组件渲染到 DOM 树的其他位置：<div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code>&lt;Teleport to=&quot;#target&quot;&gt;
  &lt;div&gt;渲染到目标节点&lt;/div&gt;
&lt;/Teleport&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li>常用于模态框、通知等全局组件。</li></ul><hr><h3 id="vue-3-如何优化大列表渲染性能" tabindex="-1"><a class="header-anchor" href="#vue-3-如何优化大列表渲染性能" aria-hidden="true">#</a> Vue 3 如何优化大列表渲染性能？</h3><ul><li>虚拟滚动（如 <code>vue-virtual-scroller</code>）。</li><li>使用 <code>v-once</code> 渲染静态内容。</li><li>动态组件懒加载。</li></ul><hr><h3 id="什么是-script-setup-与普通-setup-有何不同" tabindex="-1"><a class="header-anchor" href="#什么是-script-setup-与普通-setup-有何不同" aria-hidden="true">#</a> 什么是 <code>script setup</code>？与普通 <code>setup</code> 有何不同？</h3><ul><li><code>script setup</code> 是 Composition API 的语法糖： <ul><li>代码更简洁，无需手动返回绑定数据。</li><li>自动将所有顶层变量暴露到模板中。</li></ul><div class="language-vue ext-vue line-numbers-mode"><pre class="language-vue"><code>&lt;script setup&gt;
import { ref } from &#39;vue&#39;;
const count = ref(0);
const increment = () =&gt; count.value++;
&lt;/script&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul><hr><h3 id="vue-3-如何实现自定义指令" tabindex="-1"><a class="header-anchor" href="#vue-3-如何实现自定义指令" aria-hidden="true">#</a> Vue 3 如何实现自定义指令？</h3><ul><li>创建指令：<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>app.directive(&#39;focus&#39;, {
  mounted(el) {
    el.focus();
  },
});
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li>使用场景：操作 DOM 元素、绑定事件等。</li></ul><hr><h3 id="vue-3-项目中如何使用-typescript" tabindex="-1"><a class="header-anchor" href="#vue-3-项目中如何使用-typescript" aria-hidden="true">#</a> Vue 3 项目中如何使用 TypeScript？</h3><ul><li><p>定义 <code>props</code> 和 <code>emits</code> 类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>defineProps&lt;{ msg: string }&gt;();
defineEmits&lt;{ (event: &#39;submit&#39;, payload: string): void }&gt;();
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p>给响应式数据添加类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>import { ref } from &#39;vue&#39;;
const count = ref&lt;number&gt;(0);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul><hr><h3 id="vue-3-中如何实现状态管理" tabindex="-1"><a class="header-anchor" href="#vue-3-中如何实现状态管理" aria-hidden="true">#</a> Vue 3 中如何实现状态管理？</h3><ul><li>使用 Vuex 或 Pinia (推荐 Pinia)：<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>// Pinia 示例
import { defineStore } from &#39;pinia&#39;;
export const useStore = defineStore(&#39;main&#39;, {
  state: () =&gt; ({ count: 0 }),
  actions: {
    increment() {
      this.count++;
    },
  },
});
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li></ul><hr><h3 id="vue-3-项目如何优化性能" tabindex="-1"><a class="header-anchor" href="#vue-3-项目如何优化性能" aria-hidden="true">#</a> Vue 3 项目如何优化性能？</h3><ul><li>具体方法： <ul><li>按需加载（如 <code>dynamic import</code>）。</li><li>减少 DOM 操作，使用 <code>Fragment</code>。</li><li>使用 <code>Suspense</code> 实现异步组件的加载占位。</li></ul></li></ul><hr><h3 id="vue-3-中如何设计一个可复用的表单组件" tabindex="-1"><a class="header-anchor" href="#vue-3-中如何设计一个可复用的表单组件" aria-hidden="true">#</a> Vue 3 中如何设计一个可复用的表单组件？</h3><ul><li>使用 <code>v-model</code> 绑定表单值。</li><li>通过 <code>props</code> 和 <code>emit</code> 提供配置和事件传递。</li><li>使用 <code>slots</code> 实现灵活布局。</li></ul><hr><h3 id="vue-3-与其他前端框架-如-react-的优劣对比" tabindex="-1"><a class="header-anchor" href="#vue-3-与其他前端框架-如-react-的优劣对比" aria-hidden="true">#</a> Vue 3 与其他前端框架（如 React）的优劣对比？</h3><ul><li><strong>优势</strong>： <ul><li>模板语法直观，易上手。</li><li>Composition API 兼具灵活性和清晰性。</li><li>内置指令和工具（如 Teleport）。</li></ul></li><li><strong>劣势</strong>： <ul><li>社区生态相较 React 略逊。</li></ul></li></ul><hr><h3 id="vue-2-项目迁移到-vue-3-的难点是什么" tabindex="-1"><a class="header-anchor" href="#vue-2-项目迁移到-vue-3-的难点是什么" aria-hidden="true">#</a> Vue 2 项目迁移到 Vue 3 的难点是什么？</h3><ul><li>响应式机制变化（需替换 <code>Vue.observable</code>）。</li><li>Options API 与 Composition API 的适配。</li><li>全局 API 改动（如 <code>Vue.use</code> 改为 <code>app.use</code>）。</li></ul><hr><h2 id="uni-app" tabindex="-1"><a class="header-anchor" href="#uni-app" aria-hidden="true">#</a> uni-app</h2><h3 id="uni-app-中如何做权限控制-如果在-uniapp-的路由跳转-api-中做权限控制-怎么改写" tabindex="-1"><a class="header-anchor" href="#uni-app-中如何做权限控制-如果在-uniapp-的路由跳转-api-中做权限控制-怎么改写" aria-hidden="true">#</a> uni-app 中如何做权限控制，如果在 uniapp 的路由跳转 API 中做权限控制，怎么改写</h3><ol><li>定义权限校验逻辑 创建一个工具函数文件 <code>permission.js</code>，专门处理权限校验：</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>// permission.js
export function checkAuth() {
  const token = uni.getStorageSync(&#39;userToken&#39;); // 从本地存储获取 token
  return !!token; // 如果 token 存在，返回 true；否则返回 false
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><hr><ol start="2"><li>封装路由跳转方法 重写 uni-app 路由跳转 API，比如 <code>navigateTo</code>：</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>// router.js
import { checkAuth } from &#39;./permission.js&#39;;

function navigateTo(options) {
  // 判断目标页面是否需要权限
  const { url } = options;
  const authRequiredPages = [&#39;/pages/profile/profile&#39;, &#39;/pages/orders/orders&#39;]; // 定义需要权限的页面
  const isAuthRequired = authRequiredPages.some((path) =&gt; url.includes(path));

  if (isAuthRequired &amp;&amp; !checkAuth()) {
    // 未登录或无权限，跳转到登录页面
    uni.showToast({
      title: &#39;请先登录&#39;,
      icon: &#39;none&#39;,
    });
    setTimeout(() =&gt; {
      uni.redirectTo({ url: &#39;/pages/login/login&#39; });
    }, 1500);
    return;
  }

  // 权限校验通过，正常跳转
  uni.navigateTo(options);
}

function switchTab(options) {
  // 如果目标页面需要权限，同样进行校验
  const { url } = options;
  const authRequiredTabs = [&#39;/pages/profile/profile&#39;];
  const isAuthRequired = authRequiredTabs.some((path) =&gt; url.includes(path));

  if (isAuthRequired &amp;&amp; !checkAuth()) {
    uni.showToast({
      title: &#39;请先登录&#39;,
      icon: &#39;none&#39;,
    });
    setTimeout(() =&gt; {
      uni.redirectTo({ url: &#39;/pages/login/login&#39; });
    }, 1500);
    return;
  }

  // 权限校验通过，正常跳转
  uni.switchTab(options);
}

export { navigateTo, switchTab };
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><hr><ol start="3"><li>替换全局路由方法 在项目中，替换所有原生路由跳转调用，将其指向自定义封装的方法。例如，在业务逻辑中：</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>import { navigateTo, switchTab } from &#39;./router.js&#39;;

// 页面跳转
navigateTo({
  url: &#39;/pages/profile/profile&#39;,
});

// 切换 Tab
switchTab({
  url: &#39;/pages/profile/profile&#39;,
});
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><hr><ol start="4"><li>登录后的权限存储 在用户登录成功后，将 token 或权限标识存储在本地：</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>uni.setStorageSync(&#39;userToken&#39;, &#39;your-token-value&#39;);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>退出登录时清除 token：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>uni.removeStorageSync(&#39;userToken&#39;);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><hr><h2 id="vue-router" tabindex="-1"><a class="header-anchor" href="#vue-router" aria-hidden="true">#</a> Vue-router</h2><h3 id="vue-router-的-hash-模式和-history-模式有什么区别" tabindex="-1"><a class="header-anchor" href="#vue-router-的-hash-模式和-history-模式有什么区别" aria-hidden="true">#</a> Vue-router 的 hash 模式和 history 模式有什么区别？</h3><p><code>hash</code> 模式: 使用 URL 的 <code>hash</code> 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。它的特点如下:</p><ul><li>会占用原本 hash 锚点定位的功能</li><li>页面的路径以 <code>#</code> 开头，不方便用户记忆</li></ul><p><code>history</code> 模式: 利用 <code>history.pushState</code> API 来完成 <code>URL</code> 跳转而无须重新加载页面。</p><ul><li>使用该模式的页面像正常的 URL</li><li>需要服务端支持，若服务端没有正确配置，用户一刷新页面就会返回 404</li></ul><h3 id="vue-router-的-beforeeach-和-aftereach-一般用法-使用场景" tabindex="-1"><a class="header-anchor" href="#vue-router-的-beforeeach-和-aftereach-一般用法-使用场景" aria-hidden="true">#</a> Vue router 的 beforeEach 和 afterEach 一般用法/使用场景?</h3><p><code>beforeEach</code> 可以从路由 <code>meta</code> 中获取元数据来处理一些东西。比如在 <code>router meta</code> 中设置 <code>title</code> 的信息。还可以用于用户权限校验，当用户没有足够的权限访问目标页面的话，那就阻止页面跳转。</p><p><code>afterEach</code> 当页面切换后可以在此钩子将页面的滚动距离滚回顶部。</p><h2 id="vuex" tabindex="-1"><a class="header-anchor" href="#vuex" aria-hidden="true">#</a> Vuex</h2><h3 id="vue-中的-action-和-mutation-的区别" tabindex="-1"><a class="header-anchor" href="#vue-中的-action-和-mutation-的区别" aria-hidden="true">#</a> Vue 中的 action 和 mutation 的区别</h3><ol><li>action 可以处理异步，mutation 不可以</li><li>mutation 一般做原子操作，action 则可以整合多个 mutation</li></ol><h2 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化" aria-hidden="true">#</a> 性能优化</h2><p>在使用层面上需要注意以下几点:</p><ul><li>根据业务场景合理的使用 <code>v-if</code> 和 <code>v-show</code></li><li>合理使用 <code>computed</code></li><li><code>v-for</code> 循环时加上唯一的 <code>key</code>, 避免和 <code>v-if</code> 同时使用</li><li>在组件内创建的自定义事件、DOM 事件监听器在组件销毁前要销毁，避免内存泄露。</li><li>根据业务场景合理使用 <code>keep-alive</code></li><li>data 层级不易过深</li><li>服务端渲染处理首屏空白问题 (SSR)</li></ul><h2 id="vue-与-react-的区别" tabindex="-1"><a class="header-anchor" href="#vue-与-react-的区别" aria-hidden="true">#</a> Vue 与 React 的区别</h2><blockquote><p>如果候选者 Vue 和 react 都开发过项目的话，面试官可能会问两者的差别，技术选型的理由</p></blockquote><ol><li>在语法层面上 React 使用 JSX，Vue 使用模板。</li><li>在编程思想上，React 是函数式编程，Vue 是声明式编程</li><li>React 相比 Vue 会更精简，同时学习成本会更高一些。Vue 的语法糖和封装程度比 React 高。比如 Vue 原生的 <code>watch</code>、<code>keep-alive</code> 等功能都需要 React 用户自己去实现，而 <code>Vue</code> 可以只关注使用。</li></ol><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/anran758/front-end-lab/edit/main/docs/topic/vue.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页"><!--[--><!--]--> 在 GitHub 上编辑此页 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: anran758@gmail.com">anran758</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/front-end-lab/topic/react.html" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></span><span class="next"><a href="/front-end-lab/topic/webpack.html" class="" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!----><!--]--></div>
    <script type="module" src="/front-end-lab/assets/app.7e3542fd.js" defer></script>
  </body>
</html>
