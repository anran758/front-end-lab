<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.43">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icons/logo.svg"><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3eaf7c"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png"><link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c"><meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png"><meta name="msapplication-TileColor" content="#000000"><title>JavaScript | Web 实验室</title><meta name="description" content="Web 开发笔记与解决方案">
    <link rel="modulepreload" href="/front-end-lab/assets/app.7e3542fd.js"><link rel="modulepreload" href="/front-end-lab/assets/js.html.cc262594.js"><link rel="modulepreload" href="/front-end-lab/assets/js.html.38c63a70.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.e7c7dfe3.js"><link rel="prefetch" href="/front-end-lab/assets/dev-ops.html.d9074cc4.js"><link rel="prefetch" href="/front-end-lab/assets/git.html.27d18005.js"><link rel="prefetch" href="/front-end-lab/assets/hg.html.ff79f0d9.js"><link rel="prefetch" href="/front-end-lab/assets/jira.html.0c237662.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.810ddd82.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.6469d7a5.js"><link rel="prefetch" href="/front-end-lab/assets/solution.html.5afd378d.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.c71521b0.js"><link rel="prefetch" href="/front-end-lab/assets/books.html.6327d865.js"><link rel="prefetch" href="/front-end-lab/assets/en.html.e7167ed6.js"><link rel="prefetch" href="/front-end-lab/assets/glossary.html.fd131189.js"><link rel="prefetch" href="/front-end-lab/assets/links.html.8332b8c7.js"><link rel="prefetch" href="/front-end-lab/assets/DSA.html.57440d21.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.02a2d028.js"><link rel="prefetch" href="/front-end-lab/assets/browser.html.84c949f3.js"><link rel="prefetch" href="/front-end-lab/assets/complex.html.570ca66e.js"><link rel="prefetch" href="/front-end-lab/assets/css.html.6b4f2d56.js"><link rel="prefetch" href="/front-end-lab/assets/html.html.57c9ce1f.js"><link rel="prefetch" href="/front-end-lab/assets/network.html.da899413.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.51a3b96e.js"><link rel="prefetch" href="/front-end-lab/assets/performance.html.63cc74aa.js"><link rel="prefetch" href="/front-end-lab/assets/react.html.36044864.js"><link rel="prefetch" href="/front-end-lab/assets/vue.html.ec50a369.js"><link rel="prefetch" href="/front-end-lab/assets/webpack.html.bb5e5214.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.fd680d38.js"><link rel="prefetch" href="/front-end-lab/assets/theory.html.dbb9f444.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.f8b80dc7.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.a02bc52a.js"><link rel="prefetch" href="/front-end-lab/assets/libs.html.6613741a.js"><link rel="prefetch" href="/front-end-lab/assets/mini-program.html.362a7b5e.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.bced9d1d.js"><link rel="prefetch" href="/front-end-lab/assets/react.html.be089b0c.js"><link rel="prefetch" href="/front-end-lab/assets/typescript.html.b81e302c.js"><link rel="prefetch" href="/front-end-lab/assets/vue.html.6c6310d6.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.01b7fc15.js"><link rel="prefetch" href="/front-end-lab/assets/js.html.e6c64a8b.js"><link rel="prefetch" href="/front-end-lab/assets/404.html.93146c89.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.40f4d2a6.js"><link rel="prefetch" href="/front-end-lab/assets/dev-ops.html.c0960052.js"><link rel="prefetch" href="/front-end-lab/assets/git.html.41537809.js"><link rel="prefetch" href="/front-end-lab/assets/hg.html.17f987b4.js"><link rel="prefetch" href="/front-end-lab/assets/jira.html.68640a9e.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.c58a0cd1.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.deec9f06.js"><link rel="prefetch" href="/front-end-lab/assets/solution.html.6a378377.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.5cc031eb.js"><link rel="prefetch" href="/front-end-lab/assets/books.html.e32a031a.js"><link rel="prefetch" href="/front-end-lab/assets/en.html.d325de39.js"><link rel="prefetch" href="/front-end-lab/assets/glossary.html.7ed66620.js"><link rel="prefetch" href="/front-end-lab/assets/links.html.e82dc647.js"><link rel="prefetch" href="/front-end-lab/assets/DSA.html.15989b65.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.603e7e96.js"><link rel="prefetch" href="/front-end-lab/assets/browser.html.55e7d69d.js"><link rel="prefetch" href="/front-end-lab/assets/complex.html.3ed293bc.js"><link rel="prefetch" href="/front-end-lab/assets/css.html.38794eaf.js"><link rel="prefetch" href="/front-end-lab/assets/html.html.5aec342c.js"><link rel="prefetch" href="/front-end-lab/assets/network.html.8aef4433.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.9f7ed822.js"><link rel="prefetch" href="/front-end-lab/assets/performance.html.690a0c9d.js"><link rel="prefetch" href="/front-end-lab/assets/react.html.14ee0078.js"><link rel="prefetch" href="/front-end-lab/assets/vue.html.d61da977.js"><link rel="prefetch" href="/front-end-lab/assets/webpack.html.260b310c.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.75d084b5.js"><link rel="prefetch" href="/front-end-lab/assets/theory.html.22272636.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.f1791b22.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.1e2fa0a1.js"><link rel="prefetch" href="/front-end-lab/assets/libs.html.f9cc5d37.js"><link rel="prefetch" href="/front-end-lab/assets/mini-program.html.2d329abf.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.d13fa671.js"><link rel="prefetch" href="/front-end-lab/assets/react.html.ac39f89d.js"><link rel="prefetch" href="/front-end-lab/assets/typescript.html.e91b5fe8.js"><link rel="prefetch" href="/front-end-lab/assets/vue.html.20ecf664.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.31930719.js"><link rel="prefetch" href="/front-end-lab/assets/js.html.11f7a0c4.js"><link rel="prefetch" href="/front-end-lab/assets/404.html.5307af31.js"><link rel="prefetch" href="/front-end-lab/assets/404.9de9fb53.js"><link rel="prefetch" href="/front-end-lab/assets/Layout.f1d6f6f4.js"><link rel="prefetch" href="/front-end-lab/assets/hide-outbound.d7dc1fa7.js"><link rel="prefetch" href="/front-end-lab/assets/index.0e8935cb.js">
    <link rel="stylesheet" href="/front-end-lab/assets/style.75a6fca5.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="切换侧边栏" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/front-end-lab/" class=""><!----><span class="site-name">Web 实验室</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/front-end-lab/develop/" class="" aria-label="Web 开发"><!--[--><!--]--> Web 开发 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/front-end-lab/topic/" class="router-link-active" aria-label="技术要点"><!--[--><!--]--> 技术要点 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Homepage"><!--[--><!--]--> Anran758&#39;s Homepage <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/blog/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Blog"><!--[--><!--]--> Anran758&#39;s Blog <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/anran758/front-end-lab" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="切换夜间模式"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="Search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/front-end-lab/develop/" class="" aria-label="Web 开发"><!--[--><!--]--> Web 开发 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/front-end-lab/topic/" class="router-link-active" aria-label="技术要点"><!--[--><!--]--> 技术要点 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Homepage"><!--[--><!--]--> Anran758&#39;s Homepage <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/blog/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Blog"><!--[--><!--]--> Anran758&#39;s Blog <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/anran758/front-end-lab" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">Web 技术栈 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/front-end-lab/topic/html.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/css.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/js.html#基础概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="基础概念"><!--[--><!--]--> 基础概念 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/js.html#什么是纯函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是纯函数"><!--[--><!--]--> 什么是纯函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#谈谈对-mvvm-的理解" class="router-link-active router-link-exact-active sidebar-item" aria-label="谈谈对 MVVM 的理解"><!--[--><!--]--> 谈谈对 MVVM 的理解 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#什么是闭包-列举闭包的应用场景" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是闭包？列举闭包的应用场景"><!--[--><!--]--> 什么是闭包？列举闭包的应用场景 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#什么是科里化" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是科里化？"><!--[--><!--]--> 什么是科里化？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#节流与防抖" class="router-link-active router-link-exact-active sidebar-item" aria-label="节流与防抖"><!--[--><!--]--> 节流与防抖 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#什么是事件循环" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是事件循环?"><!--[--><!--]--> 什么是事件循环? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#宏任务和微任务的区分是为了做什么-它们的优先级" class="router-link-active router-link-exact-active sidebar-item" aria-label="宏任务和微任务的区分是为了做什么? 它们的优先级?"><!--[--><!--]--> 宏任务和微任务的区分是为了做什么? 它们的优先级? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#settimeout-是否有误差-若有-产生误差的原因是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="setTimeout 是否有误差？若有，产生误差的原因是什么？"><!--[--><!--]--> setTimeout 是否有误差？若有，产生误差的原因是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#fetch-与-xhr-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="Fetch 与 XHR 的区别?"><!--[--><!--]--> Fetch 与 XHR 的区别? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#bind、call、apply-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="bind、call、apply 的区别?"><!--[--><!--]--> bind、call、apply 的区别? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#如何检测变量的类型-尽可能多-描述可能出现的问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="如何检测变量的类型(尽可能多，描述可能出现的问题)?"><!--[--><!--]--> 如何检测变量的类型(尽可能多，描述可能出现的问题)? <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#数组" class="router-link-active router-link-exact-active sidebar-item" aria-label="数组"><!--[--><!--]--> 数组 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/js.html#数组去重" class="router-link-active router-link-exact-active sidebar-item" aria-label="数组去重"><!--[--><!--]--> 数组去重 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#数组多层扁平化" class="router-link-active router-link-exact-active sidebar-item" aria-label="数组多层扁平化"><!--[--><!--]--> 数组多层扁平化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#深拷贝数组和对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="深拷贝数组和对象"><!--[--><!--]--> 深拷贝数组和对象 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#数组里面有-10-万个数据-取第-1-个数据与第-10-万个数据的时间相差多少" class="router-link-active router-link-exact-active sidebar-item" aria-label="数组里面有 10 万个数据，取第 1 个数据与第 10 万个数据的时间相差多少？"><!--[--><!--]--> 数组里面有 10 万个数据，取第 1 个数据与第 10 万个数据的时间相差多少？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#数组的-map-和-foreach-有什么区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="数组的 map 和 forEach 有什么区别？"><!--[--><!--]--> 数组的 map 和 forEach 有什么区别？ <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#原型链" class="router-link-active router-link-exact-active sidebar-item" aria-label="原型链"><!--[--><!--]--> 原型链 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/js.html#简述一下原型链" class="router-link-active router-link-exact-active sidebar-item" aria-label="简述一下原型链"><!--[--><!--]--> 简述一下原型链 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#prototype、-proto-和-constructor-的关系" class="router-link-active router-link-exact-active sidebar-item" aria-label="prototype、 proto 和 constructor 的关系"><!--[--><!--]--> prototype、 proto 和 constructor 的关系 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#你觉得-js-里-this-的设计怎么样-有没有什么缺点啥的" class="router-link-active router-link-exact-active sidebar-item" aria-label="你觉得 js 里 this 的设计怎么样? 有没有什么缺点啥的"><!--[--><!--]--> 你觉得 js 里 this 的设计怎么样? 有没有什么缺点啥的 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#导致-js-里-this-指向混乱的原因是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="导致 js 里 this 指向混乱的原因是什么?"><!--[--><!--]--> 导致 js 里 this 指向混乱的原因是什么? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#function-和箭头函数的定义有什么区别-导致了在-this-指向这块表现不同" class="router-link-active router-link-exact-active sidebar-item" aria-label="function 和箭头函数的定义有什么区别? 导致了在 this 指向这块表现不同"><!--[--><!--]--> function 和箭头函数的定义有什么区别? 导致了在 this 指向这块表现不同 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#es6" class="router-link-active router-link-exact-active sidebar-item" aria-label="ES6"><!--[--><!--]--> ES6 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/js.html#使用过-es6-吗-你常用的有哪一些" class="router-link-active router-link-exact-active sidebar-item" aria-label="使用过 ES6 吗？你常用的有哪一些？"><!--[--><!--]--> 使用过 ES6 吗？你常用的有哪一些？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#简述一下-promise-的特点" class="router-link-active router-link-exact-active sidebar-item" aria-label="简述一下 Promise 的特点"><!--[--><!--]--> 简述一下 Promise 的特点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#promise-怎么做异常处理" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise 怎么做异常处理?"><!--[--><!--]--> Promise 怎么做异常处理? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#promise-如何串联加载" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise 如何串联加载?"><!--[--><!--]--> Promise 如何串联加载? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#promise-如何并行加载" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise 如何并行加载?"><!--[--><!--]--> Promise 如何并行加载? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#promise-如何限制并发-⭐️" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise 如何限制并发？⭐️"><!--[--><!--]--> Promise 如何限制并发？⭐️ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#async-await-是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="async/await 是什么"><!--[--><!--]--> async/await 是什么 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#装饰器是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="装饰器是什么"><!--[--><!--]--> 装饰器是什么 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#generator-是如何做到中断和恢复的" class="router-link-active router-link-exact-active sidebar-item" aria-label="generator 是如何做到中断和恢复的"><!--[--><!--]--> generator 是如何做到中断和恢复的 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#实践" class="router-link-active router-link-exact-active sidebar-item" aria-label="实践"><!--[--><!--]--> 实践 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/js.html#sleep-函数如何实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="sleep 函数如何实现？"><!--[--><!--]--> sleep 函数如何实现？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#js-超过-number-最大值的数怎么处理" class="router-link-active router-link-exact-active sidebar-item" aria-label="js 超过 Number 最大值的数怎么处理?"><!--[--><!--]--> js 超过 Number 最大值的数怎么处理? <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#综合" class="router-link-active router-link-exact-active sidebar-item" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/js.html#为什么要引入-typescript-引入的好处是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="为什么要引入 TypeScript，引入的好处是什么？"><!--[--><!--]--> 为什么要引入 TypeScript，引入的好处是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#typescript-is-这个关键字是做什么的" class="router-link-active router-link-exact-active sidebar-item" aria-label="TypeScript is 这个关键字是做什么的?"><!--[--><!--]--> TypeScript is 这个关键字是做什么的? <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#计算题" class="router-link-active router-link-exact-active sidebar-item" aria-label="计算题"><!--[--><!--]--> 计算题 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/front-end-lab/topic/nodejs.html" class="sidebar-item" aria-label="Node.js (服务端开发)"><!--[--><!--]--> Node.js (服务端开发) <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">开发框架与工具 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/front-end-lab/topic/react.html" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/vue.html" class="sidebar-item" aria-label="Vue.js"><!--[--><!--]--> Vue.js <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">优化与原理解析 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/front-end-lab/topic/browser.html" class="sidebar-item" aria-label="浏览器工作原理"><!--[--><!--]--> 浏览器工作原理 <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/performance.html" class="sidebar-item" aria-label="应用优化"><!--[--><!--]--> 应用优化 <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/network.html" class="sidebar-item" aria-label="网络原理"><!--[--><!--]--> 网络原理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/front-end-lab/topic/complex.html" class="sidebar-item sidebar-heading" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript" aria-hidden="true">#</a> JavaScript</h1><p><strong>目录</strong></p><nav class="table-of-contents"><ul><li><a aria-current="page" href="/front-end-lab/topic/js.html#基础概念" class="router-link-active router-link-exact-active">基础概念</a><ul><li><a aria-current="page" href="/front-end-lab/topic/js.html#什么是纯函数" class="router-link-active router-link-exact-active">什么是纯函数</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#谈谈对-mvvm-的理解" class="router-link-active router-link-exact-active">谈谈对 MVVM 的理解</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#什么是闭包-列举闭包的应用场景" class="router-link-active router-link-exact-active">什么是闭包？列举闭包的应用场景</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#什么是科里化" class="router-link-active router-link-exact-active">什么是科里化？</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#节流与防抖" class="router-link-active router-link-exact-active">节流与防抖</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#什么是事件循环" class="router-link-active router-link-exact-active">什么是事件循环?</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#宏任务和微任务的区分是为了做什么-它们的优先级" class="router-link-active router-link-exact-active">宏任务和微任务的区分是为了做什么? 它们的优先级?</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#settimeout-是否有误差-若有-产生误差的原因是什么" class="router-link-active router-link-exact-active">setTimeout 是否有误差？若有，产生误差的原因是什么？</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#fetch-与-xhr-的区别" class="router-link-active router-link-exact-active">Fetch 与 XHR 的区别?</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#bind、call、apply-的区别" class="router-link-active router-link-exact-active">bind、call、apply 的区别?</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#如何检测变量的类型-尽可能多-描述可能出现的问题" class="router-link-active router-link-exact-active">如何检测变量的类型(尽可能多，描述可能出现的问题)?</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#数组" class="router-link-active router-link-exact-active">数组</a><ul><li><a aria-current="page" href="/front-end-lab/topic/js.html#数组去重" class="router-link-active router-link-exact-active">数组去重</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#数组多层扁平化" class="router-link-active router-link-exact-active">数组多层扁平化</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#深拷贝数组和对象" class="router-link-active router-link-exact-active">深拷贝数组和对象</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#数组里面有-10-万个数据-取第-1-个数据与第-10-万个数据的时间相差多少" class="router-link-active router-link-exact-active">数组里面有 10 万个数据，取第 1 个数据与第 10 万个数据的时间相差多少？</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#数组的-map-和-foreach-有什么区别" class="router-link-active router-link-exact-active">数组的 map 和 forEach 有什么区别？</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#原型链" class="router-link-active router-link-exact-active">原型链</a><ul><li><a aria-current="page" href="/front-end-lab/topic/js.html#简述一下原型链" class="router-link-active router-link-exact-active">简述一下原型链</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#prototype、-proto-和-constructor-的关系" class="router-link-active router-link-exact-active">prototype、 proto 和 constructor 的关系</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#你觉得-js-里-this-的设计怎么样-有没有什么缺点啥的" class="router-link-active router-link-exact-active">你觉得 js 里 this 的设计怎么样? 有没有什么缺点啥的</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#导致-js-里-this-指向混乱的原因是什么" class="router-link-active router-link-exact-active">导致 js 里 this 指向混乱的原因是什么?</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#function-和箭头函数的定义有什么区别-导致了在-this-指向这块表现不同" class="router-link-active router-link-exact-active">function 和箭头函数的定义有什么区别? 导致了在 this 指向这块表现不同</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#es6" class="router-link-active router-link-exact-active">ES6</a><ul><li><a aria-current="page" href="/front-end-lab/topic/js.html#使用过-es6-吗-你常用的有哪一些" class="router-link-active router-link-exact-active">使用过 ES6 吗？你常用的有哪一些？</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#简述一下-promise-的特点" class="router-link-active router-link-exact-active">简述一下 Promise 的特点</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#promise-怎么做异常处理" class="router-link-active router-link-exact-active">Promise 怎么做异常处理?</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#promise-如何串联加载" class="router-link-active router-link-exact-active">Promise 如何串联加载?</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#promise-如何并行加载" class="router-link-active router-link-exact-active">Promise 如何并行加载?</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#promise-如何限制并发-⭐️" class="router-link-active router-link-exact-active">Promise 如何限制并发？⭐️</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#async-await-是什么" class="router-link-active router-link-exact-active">async/await 是什么</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#装饰器是什么" class="router-link-active router-link-exact-active">装饰器是什么</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#generator-是如何做到中断和恢复的" class="router-link-active router-link-exact-active">generator 是如何做到中断和恢复的</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#实践" class="router-link-active router-link-exact-active">实践</a><ul><li><a aria-current="page" href="/front-end-lab/topic/js.html#sleep-函数如何实现" class="router-link-active router-link-exact-active">sleep 函数如何实现？</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#js-超过-number-最大值的数怎么处理" class="router-link-active router-link-exact-active">js 超过 Number 最大值的数怎么处理?</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#综合" class="router-link-active router-link-exact-active">综合</a><ul><li><a aria-current="page" href="/front-end-lab/topic/js.html#为什么要引入-typescript-引入的好处是什么" class="router-link-active router-link-exact-active">为什么要引入 TypeScript，引入的好处是什么？</a></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#typescript-is-这个关键字是做什么的" class="router-link-active router-link-exact-active">TypeScript is 这个关键字是做什么的?</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/js.html#计算题" class="router-link-active router-link-exact-active">计算题</a></li></ul></nav><h2 id="基础概念" tabindex="-1"><a class="header-anchor" href="#基础概念" aria-hidden="true">#</a> 基础概念</h2><h3 id="什么是纯函数" tabindex="-1"><a class="header-anchor" href="#什么是纯函数" aria-hidden="true">#</a> 什么是纯函数</h3><p>纯函数由三大原则构成：</p><ol><li>给定相同输入，它总是返回相同的输出。</li><li>过程没有副作用 (side effect)。</li><li>没有额外的状态依赖。</li></ol><h3 id="谈谈对-mvvm-的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对-mvvm-的理解" aria-hidden="true">#</a> 谈谈对 MVVM 的理解</h3><p>MVVM (Model–view–viewmodel) 是一种软件架构模式。它主要由以下四点组成。</p><ul><li><strong>模型 (Model)</strong>: Modal 储存数据操作等逻辑。</li><li><strong>视图 (View)</strong>: View 用于展示给用户看的 UI、布局和结构。</li><li><strong>视图模型 (View model)</strong>: 暴露公共属性和命令的视图的抽象。在视图模型中，绑定器在 View 和数据绑定器之间进行通信。</li><li><strong>绑定器 (Binder)</strong>: 声明性数据和命令绑定隐含在 MVVM 模式中。绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。</li></ul><p>MVVM 架构的主要优点是实现了视图和模型之间的松耦合和数据双向绑定的功能。</p><p><img src="/front-end-lab/assets/mvvm-design.783015cd.png" alt="mvvm design"></p><h3 id="什么是闭包-列举闭包的应用场景" tabindex="-1"><a class="header-anchor" href="#什么是闭包-列举闭包的应用场景" aria-hidden="true">#</a> 什么是闭包？列举闭包的应用场景</h3><p>闭包主要指<strong>一个函数及其周围封闭词法环境中的引用构成闭包</strong>，这也是一种语言特性。从实践的角度来看，满足以下两个条件的才能称为闭包:</p><ol><li>创建该函数的上下文被销毁了，但该函数仍然存在</li><li>函数内有引用外部变量</li></ol><p>常见的应用场景是，在一个函数的局部作用域中创建一个内部函数，再将这个内部函数返回出去。 内部函数总是可以访问创建它的上下文，也就是外部函数中声明的参数和变量，即使创建内部函数的上下文已经销毁。例如:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function createName(name) {
  let prefix = &quot;developer_&quot;;
  return function showName() {
    console.log(prefix + name);
  };
}

var showName = createName(&quot;anran758&quot;);
showName();
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>调用 <code>createName</code> 后返回了一个函数并赋值给了 <code>showName</code> 变量，同时 <code>createName</code> 的上下文被销毁。 此时再调用 <code>showName</code> 函数时，尽管 <code>createName</code> 的上下文已经被销毁了，但 <code>showName</code> 中还能获取 <code>createName</code> 的内部变量与形参，这就是闭包的一种应用。</p><h3 id="什么是科里化" tabindex="-1"><a class="header-anchor" href="#什么是科里化" aria-hidden="true">#</a> 什么是科里化？</h3><p>柯里化是一种将<strong>使用多个参数的函数</strong>转换成一系列<strong>使用一个参数的函数</strong>的技术，本质上也是利用了闭包的特性。科里化可以做到<strong>参数复用</strong>和<strong>延迟执行</strong>的效果。</p><p>例如，若传入了给定函数的所定义的参数数量后执行函数:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function add(a, b, c) {
  return a + b + c;
}

function curry(fn, ...rest) {
  return fn.length !== rest.length
    ? function wrap(...args) {
        return rest.length + args.length !== fn.length
          ? (...arg) =&gt; wrap(...args, ...arg)
          : fn(...rest, ...args);
      }
    : fn(...rest);
}

curry(add)(1)(2)(3);
// 6
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="节流与防抖" tabindex="-1"><a class="header-anchor" href="#节流与防抖" aria-hidden="true">#</a> 节流与防抖</h3><p><strong>节流与防抖</strong>都是用于性能优化的技术，用于控制某些代码执行的频率。</p><p><strong>节流(Throttling)</strong></p><p>确保函数<strong>在指定的时间段</strong>内<strong>最多只执行一次</strong>。</p><p>这适用于需要频繁触发但又要求限制执行次数的场景。例如，调整窗口大小（resize）或滚动（scroll）时，可能只需要每 100 毫秒更新一次布局或执行检查，避免过多的计算和 DOM 操作。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function throttle(func, wait) {
  let timerId;
  let lastCallTime;

  return (...args) =&gt; {
    const now = Date.now();
    if (!lastCallTime) {
      // 初次调用，立即执行
      func(...args);
      lastCallTime = now;
    } else {
      // 清除上一个计划的调用
      clearTimeout(timerId);

      // 计算距离上次调用的时间
      const timeSinceLastCall = now - lastCallTime;

      // 设置一个新的定时器，延迟执行直到达到等待时间
      timerId = setTimeout(() =&gt; {
        func(...args);
        lastCallTime = now;
      }, wait - timeSinceLastCall);
    }
  }
}


window.addEventListener(&#39;resize&#39;, throttle(function() {
  console.log(&#39;Resizing...&#39;);
}, 1000));
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p><strong>防抖(Debouncing)</strong></p><p>确保函数只在<strong>最后一次事件触发后</strong>的<strong>一定延迟内</strong>执行。</p><p>这适用于诸如搜索框输入这类事件：用户停止输入后才实际执行搜索，减少不必要的查询请求或处理。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function debounce(func, delay) {
  let debounceTimer;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() =&gt; func.apply(context, args), delay);
  }
}

// 使用例子
const input = document.querySelector(&#39;input&#39;);
input.addEventListener(&#39;keyup&#39;, debounce(function() {
  console.log(&#39;Input value:&#39;, this.value);
}, 500));
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="什么是事件循环" tabindex="-1"><a class="header-anchor" href="#什么是事件循环" aria-hidden="true">#</a> 什么是事件循环?</h3><p>JavaScript 中的事件循环是一个执行模型，它允许 JavaScript 引擎处理多个事件，尽管它是单线程的。这个模型的关键组成部分包括调用栈、任务队列、微任务队列和事件循环本身。</p><ol><li><strong>调用栈</strong>：这是一个用于存储代码执行期间所有函数调用的数据结构。JavaScript 引擎一次处理调用栈中的一个函数。</li><li><strong>任务队列</strong>：异步事件（如用户交互、定时器、网络请求等）的回调函数会被添加到这个队列中。如果调用栈为空，事件循环会从任务队列中取出任务来执行。</li><li><strong>微任务队列</strong>：专门用于处理微任务（如 Promise 回调）。每次执行宏任务后，JavaScript 引擎都会检查并执行微任务队列中的所有微任务，然后再继续下一个宏任务。</li></ol><p>其中 JavaScript 的代码会被区分成<strong>同步任务</strong>和<strong>异步任务</strong>。</p><ul><li><strong>同步任务</strong>在当前执行环境中立即执行，它们直接在调用栈中按顺序处理。执行栈按照后进先出（LIFO）的原则工作。</li><li><strong>异步任务</strong>不会立即执行，它们会被区分为<strong>宏任务</strong>与<strong>微任务</strong>，然后分入不同的队列中，等待事件循环的处理。</li></ul><p><strong>宏任务</strong></p><p>宏任务通常是由宿主环境（如浏览器或Node.js）提供的 API 创建的。它们包括：</p><ul><li><code>setTimeout</code>, <code>setInterval</code> 的回调。</li><li><code>setImmediate</code>（仅在 Node.js 中）。</li><li>I/O 操作的回调（如文件读写、网络请求等）。</li><li>用户交互事件（如点击、滚动等）。</li><li><code>requestAnimationFrame</code>（主要用于浏览器的动画）。</li></ul><p><strong>微任务</strong></p><p>微任务通常是由 JavaScript 语言特性创建的，它们在当前宏任务完成后立即执行，但在下一个宏任务开始前执行。微任务包括：</p><ul><li><code>Promise.then</code>, <code>Promise.catch</code>, <code>Promise.finally</code> 的回调。</li><li>Web Workers 中的 <code>queueMicrotask()</code> 方法创建的任务。</li><li><code>MutationObserver</code> 的回调。</li><li>Node.js 环境的 <code>process.nextTick</code>。</li></ul><p><strong>事件循环的执行步骤如下：</strong></p><ol><li><strong>执行栈处理</strong>：首先执行<strong>当前宏任务</strong>中的所有代码。宏任务可能是初始的全局脚本，或者是由事件、定时器等触发的回调函数。</li><li><strong>微任务处理</strong>：当前宏任务在执行栈中的代码执行完毕后，即使还有其他宏任务在队列中等待，JavaScript 引擎也会优先处理所有微任务。</li><li><strong>宏任务队列检查</strong>：微任务全部执行完毕后，如果执行栈为空，事件循环将会检查宏任务队列。如果宏任务队列中还有任务，事件循环将取出下一个宏任务推入执行栈进行处理，重复上述流程。</li></ol><p><img src="/front-end-lab/assets/event-loop.a53cbd99.png" alt="event loop"></p><h3 id="宏任务和微任务的区分是为了做什么-它们的优先级" tabindex="-1"><a class="header-anchor" href="#宏任务和微任务的区分是为了做什么-它们的优先级" aria-hidden="true">#</a> 宏任务和微任务的区分是为了做什么? 它们的优先级?</h3><p><strong>宏任务</strong>和<strong>微任务</strong>之间的区分主要是为了管理异步事件的执行顺序和响应速度，确保关键操作快速且按顺序执行，从而提高应用性能并防止 UI 阻塞。也就是说，微任务用于处理紧急的更新，而宏任务则用于较大的、不那么紧迫的任务。</p><p>在每个宏任务执行完后，事件循环会处理所有的微任务，之后才会开始下一个宏任务。这意味着微任务总是在当前宏任务之后和下一个宏任务之前执行。</p><h3 id="settimeout-是否有误差-若有-产生误差的原因是什么" tabindex="-1"><a class="header-anchor" href="#settimeout-是否有误差-若有-产生误差的原因是什么" aria-hidden="true">#</a> <code>setTimeout</code> 是否有误差？若有，产生误差的原因是什么？</h3><p>零延迟并不意味着回调会立即执行，其等待的时间取决于微任务队列里待处理的消息数量。</p><p>以下程序依次输出的信息是:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>(function () {
  console.log(&quot;这是开始&quot;);

  setTimeout(function cb() {
    console.log(&quot;这是来自第一个回调的消息&quot;);
  });

  console.log(&quot;这是一条消息&quot;);

  setTimeout(function cb1() {
    console.log(&quot;这是来自第二个回调的消息&quot;);
  }, 0);

  console.log(&quot;这是结束&quot;);
})();

// &quot;这是开始&quot;
// &quot;这是一条消息&quot;
// &quot;这是结束&quot;
// &quot;这是来自第一个回调的消息&quot;
// &quot;这是来自第二个回调的消息&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="fetch-与-xhr-的区别" tabindex="-1"><a class="header-anchor" href="#fetch-与-xhr-的区别" aria-hidden="true">#</a> Fetch 与 XHR 的区别?</h3><ul><li><code>Fetch</code> 是基于 <code>Promise</code> 实现的, 相比 <code>XHR(XMLHttpRequest)</code> 的语法更加简洁。</li><li><code>Fetch</code> 发送请求时默认不带 <code>cookie</code> 的, 需要设置 <code>credentials</code> 的配置项</li><li>当接收到一个代表错误的 <code>HTTP</code> 状态码时, 从 <code>fetch()</code> 返回的 <code>Promise</code> 不会被标记为 <code>reject</code>, 即使响应的 <code>HTTP</code> 状态码是 <code>404</code> 或 <code>500</code>。仅当网络故障时或请求被阻止时, 才会标记为 <code>reject</code>。</li><li><code>Fetch</code> 不支持超时控制与检测请求进度</li></ul><h3 id="bind、call、apply-的区别" tabindex="-1"><a class="header-anchor" href="#bind、call、apply-的区别" aria-hidden="true">#</a> bind、call、apply 的区别?</h3><p>调用 bind 方法后返回一个新函数，新函数的 this 将被指向调用 bind 方法时的第一个参数。而其余参数将作为新函数的参数，供调用时使用</p><p>call 与 apply 第一个参数也是指定的 this 值，其余的不同是接受参数的不同。call 接受<strong>参数列表</strong>，apply 接收的是<strong>参数数组</strong>。两者相比，call 的性能会更好。</p><h3 id="如何检测变量的类型-尽可能多-描述可能出现的问题" tabindex="-1"><a class="header-anchor" href="#如何检测变量的类型-尽可能多-描述可能出现的问题" aria-hidden="true">#</a> 如何检测变量的类型(尽可能多，描述可能出现的问题)?</h3><p>主要使用 <code>typeof</code>、<code>instanceof</code>、<code>Object.prototype.toString.call</code>。还可以使用 <code>Array.isArray</code> 方法判断是否是数组，<code>Number.isNaN</code> 是否是 <code>NaN</code> 等。</p><p><code>typeof</code> 可以用于 <code>String</code>、<code>Number</code>、<code>Symbol</code>、<code>Boolean</code>、<code>undefined</code> 等类型，但用于 <code>null</code>、<code>Array</code> 类型的话会展示为 <code>object</code> 类型。</p><p><code>instanceof</code> 则是通过原型链的方式来判断对象类型。但它的局限性在于只要被操作的变量原型有上有该类型的值。它主要缺点是不能检测 <code>number</code>, <code>boolean</code>, <code>string</code> 字面量的类型。</p><p><code>Object.prototype.toString.call</code> 可以精准的判断类型的值，主要的问题是写法繁琐，可以基于此函数做一层封装:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function getBaseType(target) {
  const typeStr = Object.prototype.toString.call(target).toLocaleLowerCase();

  return typeStr.slice(8, -1);
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><hr><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h2><h3 id="数组去重" tabindex="-1"><a class="header-anchor" href="#数组去重" aria-hidden="true">#</a> 数组去重</h3><ol><li><p>利用 <code>Set</code> 结构不可重复的特性</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var info = { name: &quot;anran758&quot; };
var arr = [0, 1, 2, 2, info, 3, info];

// 通过扩展运算符将 Set 转为 Array
var newArr = [...new Set(arr)];

// 或者使用 Array.from 转为 Array
var newArr = Array.from(new Set(arr));
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>优点: 语法简洁 缺点: Set 添加新值时是通过 <a href="http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero" target="_blank" rel="noopener noreferrer">SameValueZero<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a> 算法进行比对的, 因此不能做深比较去重</p></blockquote></li><li><p>使用 <code>indexOf</code> 判断是否具有相同的项</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var info = { name: &quot;anran758&quot; };
var arr = [0, 1, 2, 2, info, 3, info];

function uniq(arr) {
  if (!arr || !arr.length) return [];

  var newArr = [];
  for (let i = 0; i &lt; arr.length - 1; i++) {
    var item = arr[i];

    if (newArr.indexOf(item) === -1) {
      newArr.push(item);
    }
  }

  return newArr;
}

var newArr = uniq(arr);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><blockquote><p>优点: 兼容低版本 IE 缺点: 没有实现深比较去重</p></blockquote></li><li><p>引入 <a href="https://www.lodashjs.com/docs/lodash.uniq" target="_blank" rel="noopener noreferrer">lodash<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a> 工具库来处理:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var arr = [0, 2, 4, 3, 3, 2, 6];

_.uniq(arr);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>还可以使用 <a href="https://www.lodashjs.com/docs/lodash.uniqWith" target="_blank" rel="noopener noreferrer">uniqWith<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a> 搭配 <a href="https://www.lodashjs.com/docs/lodash.isEqual" target="_blank" rel="noopener noreferrer">isEqual<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a> 实现深比较去重的效果。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var objects = [
  { x: 1, y: 2 },
  { x: 2, y: 1 },
  { x: 1, y: 2 },
];

_.uniqWith(objects, _.isEqual);
// =&gt; [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>优点: 语法简洁，使用方便，能满足所有去重需求 缺点: 需要额外引入第三方库</p></blockquote></li></ol><h3 id="数组多层扁平化" tabindex="-1"><a class="header-anchor" href="#数组多层扁平化" aria-hidden="true">#</a> 数组多层扁平化</h3><ol><li><p><code>Array.flat</code>: 数组的 <code>flat</code> 方法接受一个数值参数，该参数是指定需要扁平化的层数。若想将数组子项中所有数组进行扁平化，可以传入 <code>Infinity</code>。</p><p>只扁平化第 1 层:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var arr = [0, [1, [2], [[3]]], [[], 4]];
arr.flat(1);
// [0, 1, [2], [[3]], [], 4]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>全部扁平化:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>arr.flat(Infinity);
// [0, 1, 2, 3, 4]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p>通过递归的方式处理:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var arr = [0, [1, [2], [[3]]], [[], 4]];

function flatDeep(arr, depth) {
  var d = depth != null ? depth : 1;
  return d &gt; 0
    ? arr.reduce(
        (acc, val) =&gt;
          acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val),
        [],
      )
    : arr.slice();
}

flatDeep(arr, 1);
// [0, 1, [2], [[3]], [], 4]

flatDeep(arr, Infinity);
// [0, 1, 2, 3, 4]
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>递归实现有很多思路，<code>reduce</code> 循环合并是一种，<code>for</code> 循环也是一种。它们只是实现细节不同，但递归思想是相通的。</p></li></ol><h3 id="深拷贝数组和对象" tabindex="-1"><a class="header-anchor" href="#深拷贝数组和对象" aria-hidden="true">#</a> 深拷贝数组和对象</h3><ol><li><p>可以先通过 <code>JSON.stringify</code> 将数据转为 JSON 字符串，再通过 <code>JSON.parse</code> 对 JSON 字符串进行解析，可以得到全新的数组/对象。</p><p>使用该方法进行深拷贝并不算完美，<code>JSON.stringify</code> 只能序列化对象的可枚举属性，如果对象是通过构造函数生成的，那么会丢失 <code>constructor</code>。也不能对有循环引用的对象进行深拷贝。 除此之外，<code>Date</code> 对象会被序列化为字符串。正则表达式、<code>Error</code> 对象会被序列化为空对象。若属性中存在 <code>undefined</code> 则该属性会被丢弃。<code>NaN</code>、<code>Infinity</code> 等信息会被转为 <code>null</code>。 由此可见，如果被拷贝的参数中没有 <code>Date</code>、正则、函数或对象循环引用的问题，可以考虑使用该方法。</p></li><li><p>可以自己定义递归函数，参数是传入数组或对象。再遍历形参的属性或下标，如果遍历到的类型也是引用类型那就进行浅拷贝，再进行递归，直至全部属性都遍历完毕。</p></li><li><p>通过第三方类库实现，如 <code>lodash</code> 的 <code>deepClone</code> 就可以实现深拷贝。</p></li></ol><h3 id="数组里面有-10-万个数据-取第-1-个数据与第-10-万个数据的时间相差多少" tabindex="-1"><a class="header-anchor" href="#数组里面有-10-万个数据-取第-1-个数据与第-10-万个数据的时间相差多少" aria-hidden="true">#</a> 数组里面有 10 万个数据，取第 1 个数据与第 10 万个数据的时间相差多少？</h3><p><strong>A:</strong> 取元素的复杂度为 <code>O(1)</code>, 消耗时间几乎一致，差异可以忽略不计。</p><h3 id="数组的-map-和-foreach-有什么区别" tabindex="-1"><a class="header-anchor" href="#数组的-map-和-foreach-有什么区别" aria-hidden="true">#</a> 数组的 map 和 forEach 有什么区别？</h3><p><code>map</code> 将每一个元素传入函数调用后，会将函数的返回值存入新数组中，因此可以对数组做链式处理。而 <code>forEach</code> 只是将元素传入给函数调用，不会讲返回值存入新数组中。</p><p>可以参考这个回答: <a href="https://www.zhihu.com/question/278332594/answer/886056097" target="_blank" rel="noopener noreferrer">js es6 中如何比较深刻的理解 map、for、for of？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a></p><hr><h2 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链" aria-hidden="true">#</a> 原型链</h2><h3 id="简述一下原型链" tabindex="-1"><a class="header-anchor" href="#简述一下原型链" aria-hidden="true">#</a> 简述一下原型链</h3><p>原型链是实例对象与原型之间的连接，每个对象都有一个特殊的 <code>[[Prototype]]</code> 属性，它指向原型对象引用。当访问对象的某个属性时，首先会在对象自身查找这个属性。</p><p>若这个属性在自身没有找到，就会通过 <code>[[Prototype]]</code> 属性指向的原型对象上查找。如果该原型对象里也没有找到的话该属性的话，就会从这个<strong>原型对象中</strong>的 <code>[[Prototype]]</code> 属性继续往下找，直到找到属性或者 <code>[[Prototype]]</code> 的值为 <code>null</code> 时停止查找。</p><p>这一个通过 <code>[[Prototype]]</code> 链相连的机制被为原型链。</p><h3 id="prototype、-proto-和-constructor-的关系" tabindex="-1"><a class="header-anchor" href="#prototype、-proto-和-constructor-的关系" aria-hidden="true">#</a> prototype、 <strong>proto</strong> 和 constructor 的关系</h3><p><strong>简单版</strong>:</p><p>构造函数的 <code>prototype</code> 和通过该构造函数实例化出来的对象的 <code>__proto__</code> 属性是指向同一个原型对象。由于它们共享同一个原型对象，因此构造函数上的 <code>prototype.constructor</code> 等价于实例化对象的 <code>__proto__.constructor</code></p><hr><p><strong>详细版</strong>:</p><p>在 js 中，每个函数都有一个 <code>prototype</code> 属性, 该属性指向的是调用该构造函数而创建的<strong>实例的原型</strong>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function Person() {}

console.log(&quot;1. Person prototype:&quot;, Person.prototype);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>每个 js 对象中都有个 <code>__proto__</code> 属性，这个属性会指向<strong>该对象的原型</strong>。比如将 <code>Person</code> 进行实例化赋值给 <code>person1</code>, <code>person1.__proto__</code> 将指向构造函数的 <code>prototype</code>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>// 此处 Person 是构造函数
const person1 = new Person();

console.log(
  &quot;2. person1.__proto__ equal to Person.prototype:&quot;,
  person1.__proto__ === Person.prototype,
);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><details block><summary>扩展: 如果是像 `&quot;This is a string&quot;`、`18`、`true` 这种基本类型也会有 `__proto__` 属性吗？</summary><p>这里就需要引入<strong>封装对象包装</strong>的概念。当我们定义完基本类型字面量后，js 引擎自动会为这些基本类型值包装成一个对象，包装后的对象就拥有了 <code>__proto__</code> 属性:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console.log(0.__proto__);
// Uncaught SyntaxError: Invalid or unexpected token
// 上行代码会抛错，因为字面量没有来得及封装为对象。直接访问是访问失败的

// 将字面量存入变量中或使用括号提升优先级后就可以正常访问了
var n = 0;
console.log(n.__proto__);
console.log((0).__proto__);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>具体细节请参考: <strong>《你不知道的 JavaScript 中卷》 3.2 封装对象包装</strong></p></details><p>根据以上例子可以推出结论: <code>原型对象 === Person.prototype === person1.__proto__</code>。<code>person1</code> 没有 <code>prototype</code> 属性是因为该属性只有函数对象才有，但他们指向的引用是同一个。</p><p>除此之外，每个原型都有一个 <code>constructor</code> 属性默认指向关联的构造函数:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console.log(
  &quot;3. Person === Person.prototype.constructor:&quot;,
  Person === Person.prototype.constructor,
);
console.log(
  &quot;4. person1.__proto__.constructor === Person.prototype.constructor:&quot;,
  person1.__proto__.constructor === Person.prototype.constructor,
);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="custom-container warning"><p class="custom-container-title">注意</p><p><code>__proto__</code> 可能随时被废弃，若想获取原型对象，请优先使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="noopener noreferrer">Object.getPrototypeOf(object)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a> API</p></div><hr><h3 id="你觉得-js-里-this-的设计怎么样-有没有什么缺点啥的" tabindex="-1"><a class="header-anchor" href="#你觉得-js-里-this-的设计怎么样-有没有什么缺点啥的" aria-hidden="true">#</a> 你觉得 js 里 this 的设计怎么样? 有没有什么缺点啥的</h3><p>JavaScript 中的 <code>this</code> 早期设计存在一些缺陷，主要体现在行为不直观和使用复杂的额问题。</p><ol><li><code>this</code> 的值<strong>取决于函数的调用方式</strong>，而非定义方式。这在多种调用场景（如事件处理器、setTimeout等）中容易导致混淆和错误。</li><li>代码维护困难：在旧的 JavaScript 函数中，尤其是那些作为回调函数使用时，this 可能不指向预期对象，经常需要借助变量（如 <code>that</code> 或 <code>self</code>）或者 <code>.bind()</code> 方法来解决。</li><li>性能问题：频繁使用 <code>.bind()</code> 可以确保 <code>this</code> 指向正确，但可能会引入性能问题，因为每次 <code>.bind()</code> 都会创建一个新的函数实例。</li></ol><p>为了解决这些问题，ES6 引入了箭头函数，它提供了对 <code>this</code> 行为的改进：</p><p>箭头函数不自己绑定 <code>this</code>，它们会捕获其所在上下文的 <code>this</code> 值作为自己的 <code>this</code> 值。这使得箭头函数特别适合用来编写那些需要自身上下文与外围代码相同的函数，例如回调函数和事件处理器。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>class Logger {
    constructor() {
        this.logLevel = &quot;info&quot;;
    }

    display() {
        setTimeout(() =&gt; {
            console.log(this.logLevel); // 正确引用了构造函数中的 this
        }, 1000);
    }
}

new Logger().display();

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="导致-js-里-this-指向混乱的原因是什么" tabindex="-1"><a class="header-anchor" href="#导致-js-里-this-指向混乱的原因是什么" aria-hidden="true">#</a> 导致 js 里 this 指向混乱的原因是什么?</h3><p><code>this</code> 在 JavaScript 中的行为是由其调用方式决定的，这是指向混乱的根本原因。</p><h3 id="function-和箭头函数的定义有什么区别-导致了在-this-指向这块表现不同" tabindex="-1"><a class="header-anchor" href="#function-和箭头函数的定义有什么区别-导致了在-this-指向这块表现不同" aria-hidden="true">#</a> function 和箭头函数的定义有什么区别? 导致了在 this 指向这块表现不同</h3><p>传统的 <code>function</code> 在 JavaScript 中为 <code>this</code> 提供动态绑定，而箭头函数则从其定义时的上下文继承 <code>this</code>，提供更一致和可预测的行为。</p><hr><h2 id="es6" tabindex="-1"><a class="header-anchor" href="#es6" aria-hidden="true">#</a> ES6</h2><h3 id="使用过-es6-吗-你常用的有哪一些" tabindex="-1"><a class="header-anchor" href="#使用过-es6-吗-你常用的有哪一些" aria-hidden="true">#</a> 使用过 ES6 吗？你常用的有哪一些？</h3><ul><li>let/const 自身特性与块级作用域</li><li>模板字符串</li><li>解构赋值</li><li>函数默认参数</li><li>箭头函数</li><li>Promise</li><li>async/await</li></ul><h3 id="简述一下-promise-的特点" tabindex="-1"><a class="header-anchor" href="#简述一下-promise-的特点" aria-hidden="true">#</a> 简述一下 Promise 的特点</h3><ul><li>主要用于异步计算.</li><li>Promise 对象有三种状态，分别是 pending（进行中）、fulfilled（已成功）和 rejected（已失败），状态一旦改变就不会再变了。</li><li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。</li><li>可以在对象之间传递和操作 Promise，帮助我们处理队列。</li><li>链式写法更简洁，可以避免回调地狱</li></ul><h3 id="promise-怎么做异常处理" tabindex="-1"><a class="header-anchor" href="#promise-怎么做异常处理" aria-hidden="true">#</a> Promise 怎么做异常处理?</h3><ol><li>Promise 最末尾添加 catch() 是统一 catch 错误</li><li>Promise.then 的第二个参数捕获错误</li></ol><p>衍生问题:</p><p><strong>Q: <code>try...catch</code> 可以捕获 Promise.reject 错误吗，具体说说原因？</strong></p><p>A: <code>try...catch</code> 是同步代码，而 <code>Promise</code>、<code>setTimeout</code> 等语句是异步代码，因此当异步代码发生错误时，<code>try...catch</code> 代码块已经执行完毕了，因此被抛出错误。</p><h3 id="promise-如何串联加载" tabindex="-1"><a class="header-anchor" href="#promise-如何串联加载" aria-hidden="true">#</a> Promise 如何串联加载?</h3><ol><li>通过 async await ，等异步函数执行完毕取出 Promise 中的值</li><li>通过 then 链式传递串联</li></ol><h3 id="promise-如何并行加载" tabindex="-1"><a class="header-anchor" href="#promise-如何并行加载" aria-hidden="true">#</a> Promise 如何并行加载?</h3><p>可以使用 <code>Promise.all</code>。</p><p><code>Promise.all</code> 接受一个数组，数组内可以是对象、数组或者字符串等基本类型，也可以是 <code>Promise</code> 类型。</p><p>若数组中有 <code>Promise</code> 类型，当所有 <code>Promise</code> 的状态都变为成功后，就会进入 <code>Promise.all</code> 的 then 方法中，若有一项 <code>Promise</code> 状态变为 <code>reject</code>，则 <code>Promise.all</code> 的状态变为 <code>reject</code>。</p><h3 id="promise-如何限制并发-⭐️" tabindex="-1"><a class="header-anchor" href="#promise-如何限制并发-⭐️" aria-hidden="true">#</a> Promise 如何限制并发？⭐️</h3><p>实现一个批量请求函数, 能够限制并发量：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function parallelLimit(tasks, { concurrency = 10 }) {
  const results = [];
  const executing = new Set();

  let currentlyRunning = 0;
  let currentIndex = 0;

  return new Promise((resolve) =&gt; {
    const next = () =&gt; {
      if (currentIndex &lt; tasks.length) {
        // 取出记录数，准备执行
        const index = currentIndex;
        const task = tasks[index];

        currentIndex += 1;
        currentlyRunning += 1;

        const resultPromise = task().then((result) =&gt; {
          // 任务执行完毕，更新运行数、保存结果
          currentlyRunning -= 1;
          results[index] = result;
          executing.delete(resultPromise);

          // 开启下一个任务
          next();
        });

        executing.add(resultPromise);

        // 当前运行的任务数小于限制并且还有任务未开始时，继续添加任务
        if (currentlyRunning &lt; concurrency &amp;&amp; currentIndex &lt; tasks.length) {
          next();
        }
      } else if (currentlyRunning === 0) {
        // 所有任务都已完成
        resolve(results);
      }
    };

    // 初始化
    for (let i = 0; i &lt; Math.min(concurrency, tasks.length); i += 1) {
      next();
    }
  });
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><h3 id="async-await-是什么" tabindex="-1"><a class="header-anchor" href="#async-await-是什么" aria-hidden="true">#</a> async/await 是什么</h3><ul><li>async/await 是最直接的同步写法，在也没有回调函数</li><li>async/await 使用了 Promise，并没有和 Promise 产生冲突</li><li>但还是改变不了 js 单线程、异步的本质</li></ul><hr><h3 id="装饰器是什么" tabindex="-1"><a class="header-anchor" href="#装饰器是什么" aria-hidden="true">#</a> 装饰器是什么</h3><p>在JavaScript中，装饰器（Decorators）是一种特殊类型的声明，它们<strong>可以被附加到类声明、方法、访问器、属性或参数上</strong>。装饰器使用 <code>@expression</code> 这种形式，其中 <code>expression</code> 必须求值为一个函数，这个函数会在运行时被调用，被装饰的声明的信息作为参数传入。</p><p>装饰器目前仍是一个提案，并不是正式的ECMAScript标准的一部分。如果要在项目中使用装饰器，通常需要通过Babel这样的转译器来实现。</p><p>装饰器的用途包括：</p><ul><li>拦截和修改类的构造函数。</li><li>添加、修改或替换方法和访问器的定义。</li><li>修改或替换属性。</li><li>参数验证。</li><li>增加类、方法、属性的元数据。</li></ul><p>Angular 开发中广泛使用了装饰器，可以通过装饰器定义组件、模块、服务与指令等。</p><h3 id="generator-是如何做到中断和恢复的" tabindex="-1"><a class="header-anchor" href="#generator-是如何做到中断和恢复的" aria-hidden="true">#</a> generator 是如何做到中断和恢复的</h3><p><code>generator</code> 函数的中断和恢复功能主要是通过<strong>状态机</strong>来实现的，即函数封装了多个内部状态。它根据yield表达式来改变函数的执行流程。</p><p>当一个 <code>generator</code> 函数执行到 <code>yield</code> 表达式时，它会暂停执行并返回一个值（<code>yield</code> 后表达式的值）。此时，函数的状态（包括变量的值和执行位置）被保留下来。当外部代码再次调用 <code>generator</code> 的 <code>next()</code> 方法时，函数会从上次暂停的地方恢复执行，直到遇到下一个 <code>yield</code>，或者函数结束。</p><p>这种机制允许 generator 函数在执行过程中进行“中断”，并在适当的时候“恢复”，非常适合用于需要异步处理或协程的场景。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function* numberGenerator() {
    console.log(&#39;开始执行&#39;); // 这里会输出 &quot;开始执行&quot;
    yield 1;
    console.log(&#39;恢复执行&#39;); // 继续执行时会输出 &quot;恢复执行&quot;
    yield 2;
    console.log(&#39;完成执行&#39;); // 最终会输出 &quot;完成执行&quot;
}

// 创建generator对象
const generator = numberGenerator();

// 直接打印每次调用 next() 的返回值
console.log(&#39;输出: &#39;, generator.next());
console.log(&#39;输出: &#39;, generator.next());
console.log(&#39;输出: &#39;, generator.next());

// 开始执行
// 输出: { value: 1, done: false }
// 恢复执行
// 输出: { value: 2, done: false }
// 完成执行
// 输出: { value: undefined, done: true }
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>Generators 主要用途集中在：</p><ol><li><strong>惰性求值</strong>：适合按需处理大数据集或无限序列，避免一次性加载全部数据。</li><li><strong>复杂控制流</strong>：优于管理需要精确暂停和恢复的复杂状态或算法。</li><li><strong>自定义迭代器</strong>：允许精细调整迭代过程，适合特殊迭代需求。</li></ol><h2 id="实践" tabindex="-1"><a class="header-anchor" href="#实践" aria-hidden="true">#</a> 实践</h2><h3 id="sleep-函数如何实现" tabindex="-1"><a class="header-anchor" href="#sleep-函数如何实现" aria-hidden="true">#</a> sleep 函数如何实现？</h3><p>通过 <code>Promise</code> 和 <code>setTimeout</code> 实现延迟执行。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>function sleep(ms) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="js-超过-number-最大值的数怎么处理" tabindex="-1"><a class="header-anchor" href="#js-超过-number-最大值的数怎么处理" aria-hidden="true">#</a> js 超过 Number 最大值的数怎么处理?</h3><p>在 JavaScript 中处理超过 <code>Number.MAX_VALUE</code> 的数值时，传统的 <code>Number</code> 类型在达到这一限制（约为<code>1.7976931348623157e+308</code>）后无法准确表示更大的数值。这种情况下，可以考虑以下方法：</p><ol><li><p><strong>使用<code>BigInt</code>类型</strong>： <code>BigInt</code>是一个比较新的JavaScript类型，可以用来安全地处理任意大小的整数。<code>BigInt</code>可以通过在整数末尾添加<code>n</code>来创建，或者使用<code>BigInt()</code>构造函数。例如：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>let bigIntNumber = BigInt(&quot;1234567890123456789012345678901234567890&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>缺点是 <code>BigInt</code> 只能用来表示整数，不支持小数。</p></li><li><p>将 <code>Number</code> 类型转为 <code>String</code> 类型存储并通过自定义函数控制计算是一种更通用的方案，通常需要结合第三方库一起处理。</p></li></ol><hr><h2 id="综合" tabindex="-1"><a class="header-anchor" href="#综合" aria-hidden="true">#</a> 综合</h2><h3 id="为什么要引入-typescript-引入的好处是什么" tabindex="-1"><a class="header-anchor" href="#为什么要引入-typescript-引入的好处是什么" aria-hidden="true">#</a> 为什么要引入 TypeScript，引入的好处是什么？</h3><p>TypeScript 是 JavaScript 的超集，在 JavaScript 的基础上引入了类型约束。</p><ul><li>提供类型系统：增强了代码的可读性和可维护性，在编译阶段就能发现大部分错误</li><li>支持 ES6</li><li>强大的 IDE 支持: 类型检测、语法提示</li></ul><h3 id="typescript-is-这个关键字是做什么的" tabindex="-1"><a class="header-anchor" href="#typescript-is-这个关键字是做什么的" aria-hidden="true">#</a> TypeScript is 这个关键字是做什么的?</h3><p><code>is</code> 关键字用于类型谓词，主要用于用户自定义的类型保护函数中，帮助 TypeScript 编译器在编译时确认变量的具体类型。</p><p>例如，通过一个函数检查对象是否为某一类型，然后在这个确认的基础上安全地使用该对象的特定属性或方法。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>interface Bird {
  fly: () =&gt; void;
}

interface Fish {
  swim: () =&gt; void;
}

function isBird(animal: Bird | Fish): animal is Bird {
  return (animal as Bird).fly !== undefined;
}

function move(animal: Bird | Fish): void {
  if (isBird(animal)) {
    // TypeScript 现在知道 animal 是 Bird 类型
    animal.fly();
  } else {
    // TypeScript 现在知道 animal 是 Fish 类型
    animal.swim();
  }
}

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="计算题" tabindex="-1"><a class="header-anchor" href="#计算题" aria-hidden="true">#</a> 计算题</h2><p><strong>【题 1】按顺序写出程序的输出结果:</strong></p><blockquote><p>考察 this 问题</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var length = 10;

function fn() {
 alert(this.length);
}
var obj = {
 length: 5,
 callApi: function (fn) {
   fn();
   arguments[0]();
 },
};

obj.callApi(fn, 3);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>该段代码依次输出 <code>10</code>、<code>2</code>。<strong>函数的调用方式决定了 <code>this</code> 的值</strong>。第二个函数调用是通过 <code>arguments</code> 调用，那么 <code>this</code> 自然指向 <code>arguments</code>，那 <code>arguments</code> 的实参有 <code>fn</code> 跟 <code>3</code> 两个参数，因此输出 <code>2</code>。</p><hr><p><strong>【题 2】列出下面代码的不足及优化方案</strong></p><div class="custom-container tip"><p class="custom-container-title">提示</p><p>考察事件代理与 nodeList</p></div><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>var node = document.querySelectorAll(&quot;ul&quot;);

for (var i = 0; i &lt; node.length; i++) {
  node[i].addEventListener(&quot;click&quot;, function () {
    alert(&quot;click&quot; + i);
  });
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>解：</p><ol><li><p>闭包中的变量引用错误。</p><p>在循环中使用 <code>var i</code> 会导致每个事件处理器中的 <code>i</code> 都引用同一个变量，该变量在循环结束时的值是 <code>node.length</code>。因此，无论点击哪个 <code>&lt;ul&gt;</code> 元素，<code>alert</code> 显示的都是最后的 <code>i</code> 值，而不是在添加监听器时的 <code>i</code> 值。</p><p>优化方案：使用 <code>let</code> 声明变量以获取块级作用域。这样每次循环 <code>i</code> 都是一个新的变量。</p></li><li><p>当 <code>ul</code> 元素较多时，为每个元素添加 <code>click</code> 可能会有性能问题。</p><p>优化方案：可以在父元素上添加一个事件监听器来捕获所有 <code>&lt;ul&gt;</code> 的点击事件，这样可以减少 DOM 操作和内存消耗。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>// 假设所有的 ul 元素都是某个父容器的子元素
document.getElementById(&#39;parent-container&#39;).addEventListener(&#39;click&#39;, function(e) {
  if (e.target.tagName === &#39;ul&#39;) {
    let index = Array.prototype.indexOf.call(this.children, e.target);
    alert(&quot;click&quot; + index);
  }
});
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ol><hr><p><strong>【题 3】改造下面的代码，使之输出 0 ~ 9，写出你能想到的所有解法。</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>for (var i = 0; i &lt; 10; i++) {
 setTimeout(() =&gt; {
   console.log(i);
 }, 1000);
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>解法 1：</strong> <code>var</code> 改为 <code>let</code>。</p><p><strong>解法 2：</strong> 循环体内的代码改为立即执行函数，利用闭包来修复。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>for (var i = 0; i &lt; 10; i++) {
 ((j) =&gt; {
   setTimeout(() =&gt; {
     console.log(j);
   }, j * 1000);
 })(i);
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>解法 3：</strong> 将循环体内的代码封装到新函数中，在循环体中调用该函数并传入 <code>i</code>。</p><p><strong>解法 4：</strong> 将 <code>i</code> 作为 <code>setTimeout</code> 内部函数的额外参数传入。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>for (var i = 0; i &lt; 10; i++) {
 setTimeout(
   (j) =&gt; {
     console.log(j);
   },
   1000,
   i,
 );
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><hr><p><strong>【题 4】请写出下面代码的运行结果</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>async function async1() {
 console.log(&quot;async1 start&quot;);
 await async2();
 console.log(&quot;async1 end&quot;);
}

async function async2() {
 console.log(&quot;async2&quot;);
}

console.log(&quot;script start&quot;);

setTimeout(() =&gt; {
 console.log(&quot;setTimeout&quot;);
}, 0);

async1();

new Promise((reslove) =&gt; {
 console.log(&quot;promise1&quot;);
 reslove();
}).then(() =&gt; {
 console.log(&quot;promise2&quot;);
});

console.log(&quot;script end&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>依次输出的是:</p><div class="language-markdown ext-md line-numbers-mode"><pre class="language-markdown"><code>script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><a href="https://bytefish.medium.com/the-execution-order-of-asynchronous-functions-in-the-event-loop-ff641dae4f09" target="_blank" rel="noopener noreferrer"><img src="/front-end-lab/assets/event_loop.c73b43f0.gif" alt="event loop"><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a></p><hr><p><strong>【题 5】下面的代码会进入 <code>.catch</code> 吗？解释一下你的答案。</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>new Promise(() =&gt; {
  setTimeout(() =&gt; {
    throw new Error(&quot;Whoops!&quot;);
  }, 1000);
}).catch(() =&gt; console.log(&quot;catched!&quot;));
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>解：</p><p>不会进入 <code>.catch</code>, 因为 <code>try...catch</code> 无法捕获异步代码的错误。</p><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/anran758/front-end-lab/edit/main/docs/topic/js.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页"><!--[--><!--]--> 在 GitHub 上编辑此页 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: anran758@gmail.com">anran758</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/front-end-lab/topic/css.html" class="" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a></span><span class="next"><a href="/front-end-lab/topic/nodejs.html" class="" aria-label="Node.js (服务端开发)"><!--[--><!--]--> Node.js (服务端开发) <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!----><!--]--></div>
    <script type="module" src="/front-end-lab/assets/app.7e3542fd.js" defer></script>
  </body>
</html>
