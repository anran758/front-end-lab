<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.43">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/icons/logo.svg"><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3eaf7c"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png"><link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c"><meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png"><meta name="msapplication-TileColor" content="#000000"><title>React | Web 实验室</title><meta name="description" content="Web 开发笔记与解决方案">
    <link rel="modulepreload" href="/front-end-lab/assets/app.7e3542fd.js"><link rel="modulepreload" href="/front-end-lab/assets/react.html.14ee0078.js"><link rel="modulepreload" href="/front-end-lab/assets/react.html.36044864.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.e7c7dfe3.js"><link rel="prefetch" href="/front-end-lab/assets/dev-ops.html.d9074cc4.js"><link rel="prefetch" href="/front-end-lab/assets/git.html.27d18005.js"><link rel="prefetch" href="/front-end-lab/assets/hg.html.ff79f0d9.js"><link rel="prefetch" href="/front-end-lab/assets/jira.html.0c237662.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.810ddd82.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.6469d7a5.js"><link rel="prefetch" href="/front-end-lab/assets/solution.html.5afd378d.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.c71521b0.js"><link rel="prefetch" href="/front-end-lab/assets/books.html.6327d865.js"><link rel="prefetch" href="/front-end-lab/assets/en.html.e7167ed6.js"><link rel="prefetch" href="/front-end-lab/assets/glossary.html.fd131189.js"><link rel="prefetch" href="/front-end-lab/assets/links.html.8332b8c7.js"><link rel="prefetch" href="/front-end-lab/assets/DSA.html.57440d21.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.02a2d028.js"><link rel="prefetch" href="/front-end-lab/assets/browser.html.84c949f3.js"><link rel="prefetch" href="/front-end-lab/assets/complex.html.570ca66e.js"><link rel="prefetch" href="/front-end-lab/assets/css.html.6b4f2d56.js"><link rel="prefetch" href="/front-end-lab/assets/html.html.57c9ce1f.js"><link rel="prefetch" href="/front-end-lab/assets/js.html.38c63a70.js"><link rel="prefetch" href="/front-end-lab/assets/network.html.da899413.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.51a3b96e.js"><link rel="prefetch" href="/front-end-lab/assets/performance.html.63cc74aa.js"><link rel="prefetch" href="/front-end-lab/assets/vue.html.ec50a369.js"><link rel="prefetch" href="/front-end-lab/assets/webpack.html.bb5e5214.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.fd680d38.js"><link rel="prefetch" href="/front-end-lab/assets/theory.html.dbb9f444.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.f8b80dc7.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.a02bc52a.js"><link rel="prefetch" href="/front-end-lab/assets/libs.html.6613741a.js"><link rel="prefetch" href="/front-end-lab/assets/mini-program.html.362a7b5e.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.bced9d1d.js"><link rel="prefetch" href="/front-end-lab/assets/react.html.be089b0c.js"><link rel="prefetch" href="/front-end-lab/assets/typescript.html.b81e302c.js"><link rel="prefetch" href="/front-end-lab/assets/vue.html.6c6310d6.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.01b7fc15.js"><link rel="prefetch" href="/front-end-lab/assets/js.html.e6c64a8b.js"><link rel="prefetch" href="/front-end-lab/assets/404.html.93146c89.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.40f4d2a6.js"><link rel="prefetch" href="/front-end-lab/assets/dev-ops.html.c0960052.js"><link rel="prefetch" href="/front-end-lab/assets/git.html.41537809.js"><link rel="prefetch" href="/front-end-lab/assets/hg.html.17f987b4.js"><link rel="prefetch" href="/front-end-lab/assets/jira.html.68640a9e.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.c58a0cd1.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.deec9f06.js"><link rel="prefetch" href="/front-end-lab/assets/solution.html.6a378377.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.5cc031eb.js"><link rel="prefetch" href="/front-end-lab/assets/books.html.e32a031a.js"><link rel="prefetch" href="/front-end-lab/assets/en.html.d325de39.js"><link rel="prefetch" href="/front-end-lab/assets/glossary.html.7ed66620.js"><link rel="prefetch" href="/front-end-lab/assets/links.html.e82dc647.js"><link rel="prefetch" href="/front-end-lab/assets/DSA.html.15989b65.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.603e7e96.js"><link rel="prefetch" href="/front-end-lab/assets/browser.html.55e7d69d.js"><link rel="prefetch" href="/front-end-lab/assets/complex.html.3ed293bc.js"><link rel="prefetch" href="/front-end-lab/assets/css.html.38794eaf.js"><link rel="prefetch" href="/front-end-lab/assets/html.html.5aec342c.js"><link rel="prefetch" href="/front-end-lab/assets/js.html.cc262594.js"><link rel="prefetch" href="/front-end-lab/assets/network.html.8aef4433.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.9f7ed822.js"><link rel="prefetch" href="/front-end-lab/assets/performance.html.690a0c9d.js"><link rel="prefetch" href="/front-end-lab/assets/vue.html.d61da977.js"><link rel="prefetch" href="/front-end-lab/assets/webpack.html.260b310c.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.75d084b5.js"><link rel="prefetch" href="/front-end-lab/assets/theory.html.22272636.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.f1791b22.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.1e2fa0a1.js"><link rel="prefetch" href="/front-end-lab/assets/libs.html.f9cc5d37.js"><link rel="prefetch" href="/front-end-lab/assets/mini-program.html.2d329abf.js"><link rel="prefetch" href="/front-end-lab/assets/nodejs.html.d13fa671.js"><link rel="prefetch" href="/front-end-lab/assets/react.html.ac39f89d.js"><link rel="prefetch" href="/front-end-lab/assets/typescript.html.e91b5fe8.js"><link rel="prefetch" href="/front-end-lab/assets/vue.html.20ecf664.js"><link rel="prefetch" href="/front-end-lab/assets/index.html.31930719.js"><link rel="prefetch" href="/front-end-lab/assets/js.html.11f7a0c4.js"><link rel="prefetch" href="/front-end-lab/assets/404.html.5307af31.js"><link rel="prefetch" href="/front-end-lab/assets/404.9de9fb53.js"><link rel="prefetch" href="/front-end-lab/assets/Layout.f1d6f6f4.js"><link rel="prefetch" href="/front-end-lab/assets/hide-outbound.d7dc1fa7.js"><link rel="prefetch" href="/front-end-lab/assets/index.0e8935cb.js">
    <link rel="stylesheet" href="/front-end-lab/assets/style.75a6fca5.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="切换侧边栏" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/front-end-lab/" class=""><!----><span class="site-name">Web 实验室</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/front-end-lab/develop/" class="" aria-label="Web 开发"><!--[--><!--]--> Web 开发 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/front-end-lab/topic/" class="router-link-active" aria-label="技术要点"><!--[--><!--]--> 技术要点 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Homepage"><!--[--><!--]--> Anran758&#39;s Homepage <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/blog/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Blog"><!--[--><!--]--> Anran758&#39;s Blog <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/anran758/front-end-lab" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="切换夜间模式"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="Search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/front-end-lab/develop/" class="" aria-label="Web 开发"><!--[--><!--]--> Web 开发 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/front-end-lab/topic/" class="router-link-active" aria-label="技术要点"><!--[--><!--]--> 技术要点 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="扩展阅读"><span class="title">扩展阅读</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Homepage"><!--[--><!--]--> Anran758&#39;s Homepage <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://anran758.github.io/blog/" rel="noopener noreferrer" target="_blank" aria-label="Anran758&#39;s Blog"><!--[--><!--]--> Anran758&#39;s Blog <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/anran758/front-end-lab" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">Web 技术栈 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/front-end-lab/topic/html.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/css.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/js.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/nodejs.html" class="sidebar-item" aria-label="Node.js (服务端开发)"><!--[--><!--]--> Node.js (服务端开发) <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">开发框架与工具 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/react.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/react.html#基础概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="基础概念"><!--[--><!--]--> 基础概念 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-是单向数据流还是双向数据流-它还有其他特点吗" class="router-link-active router-link-exact-active sidebar-item" aria-label="React 是单向数据流还是双向数据流？它还有其他特点吗？"><!--[--><!--]--> React 是单向数据流还是双向数据流？它还有其他特点吗？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-通过什么方式来更新数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="React 通过什么方式来更新数据"><!--[--><!--]--> React 通过什么方式来更新数据 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-不能直接修改-state-吗" class="router-link-active router-link-exact-active sidebar-item" aria-label="React 不能直接修改 State 吗？"><!--[--><!--]--> React 不能直接修改 State 吗？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#setstate-是同步还是异步的" class="router-link-active router-link-exact-active sidebar-item" aria-label="setState 是同步还是异步的？"><!--[--><!--]--> setState 是同步还是异步的？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#函数组件是什么-与类组件有什么区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="函数组件是什么？与类组件有什么区别？"><!--[--><!--]--> 函数组件是什么？与类组件有什么区别？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#受控组件与非受控组件的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="受控组件与非受控组件的区别"><!--[--><!--]--> 受控组件与非受控组件的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react中的合成事件是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="React中的合成事件是什么？"><!--[--><!--]--> React中的合成事件是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#为什么浏览器无法读取jsx" class="router-link-active router-link-exact-active sidebar-item" aria-label="为什么浏览器无法读取JSX？"><!--[--><!--]--> 为什么浏览器无法读取JSX？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#jsx-是如何编译为-js-代码的" class="router-link-active router-link-exact-active sidebar-item" aria-label="JSX 是如何编译为 js 代码的？"><!--[--><!--]--> JSX 是如何编译为 js 代码的？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-生命周期" class="router-link-active router-link-exact-active sidebar-item" aria-label="React 生命周期"><!--[--><!--]--> React 生命周期 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-组件通信" class="router-link-active router-link-exact-active sidebar-item" aria-label="React 组件通信"><!--[--><!--]--> React 组件通信 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-context-怎么使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="React.Context 怎么使用"><!--[--><!--]--> React.Context 怎么使用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-怎么做代码复用" class="router-link-active router-link-exact-active sidebar-item" aria-label="React 怎么做代码复用"><!--[--><!--]--> React 怎么做代码复用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#高阶函数、高阶组件是什么" class="router-link-active router-link-exact-active sidebar-item" aria-label="高阶函数、高阶组件是什么？"><!--[--><!--]--> 高阶函数、高阶组件是什么？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#怎么对组件的参数做类型约束呢" class="router-link-active router-link-exact-active sidebar-item" aria-label="怎么对组件的参数做类型约束呢?"><!--[--><!--]--> 怎么对组件的参数做类型约束呢? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#组件设计原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="组件设计原则"><!--[--><!--]--> 组件设计原则 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#渲染与优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="渲染与优化"><!--[--><!--]--> 渲染与优化 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/react.html#渲染列表为啥要用-key" class="router-link-active router-link-exact-active sidebar-item" aria-label="渲染列表为啥要用 key？"><!--[--><!--]--> 渲染列表为啥要用 key？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#虚拟-dom-是如何提升性能的" class="router-link-active router-link-exact-active sidebar-item" aria-label="虚拟 dom 是如何提升性能的"><!--[--><!--]--> 虚拟 dom 是如何提升性能的 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-在虚拟-dom-的-diff-上-做了哪些改进使得速度很快" class="router-link-active router-link-exact-active sidebar-item" aria-label="react 在虚拟 dom 的 diff 上，做了哪些改进使得速度很快?"><!--[--><!--]--> react 在虚拟 dom 的 diff 上，做了哪些改进使得速度很快? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-diffing-算法概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="React Diffing 算法概述"><!--[--><!--]--> React Diffing 算法概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-diffing-算法的时间复杂度和空间复杂度" class="router-link-active router-link-exact-active sidebar-item" aria-label="React Diffing 算法的时间复杂度和空间复杂度"><!--[--><!--]--> React Diffing 算法的时间复杂度和空间复杂度 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-如何做性能优化" class="router-link-active router-link-exact-active sidebar-item" aria-label="React 如何做性能优化"><!--[--><!--]--> React 如何做性能优化 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#父组件在执行-render-时会不会触发子组件的-render-事件-如果会该怎么避免" class="router-link-active router-link-exact-active sidebar-item" aria-label="父组件在执行 render 时会不会触发子组件的 render 事件？如果会该怎么避免？"><!--[--><!--]--> 父组件在执行 render 时会不会触发子组件的 render 事件？如果会该怎么避免？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#什么是-portals" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是 Portals?"><!--[--><!--]--> 什么是 Portals? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#什么是-react-fiber" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是 React Fiber?"><!--[--><!--]--> 什么是 React Fiber? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#说说-fiber-架构是怎么实现的" class="router-link-active router-link-exact-active sidebar-item" aria-label="说说 Fiber 架构是怎么实现的"><!--[--><!--]--> 说说 Fiber 架构是怎么实现的 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#fiber-和-stack-的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="Fiber 和 Stack 的区别"><!--[--><!--]--> Fiber 和 Stack 的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#异步组件怎么使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="异步组件怎么使用？"><!--[--><!--]--> 异步组件怎么使用？ <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#hooks" class="router-link-active router-link-exact-active sidebar-item" aria-label="Hooks"><!--[--><!--]--> Hooks <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/react.html#hooks-相比-class-的优点" class="router-link-active router-link-exact-active sidebar-item" aria-label="Hooks 相比 class 的优点"><!--[--><!--]--> Hooks 相比 class 的优点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#hooks-的使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="Hooks 的使用"><!--[--><!--]--> Hooks 的使用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#自定义-hook-怎么使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="自定义 Hook 怎么使用"><!--[--><!--]--> 自定义 Hook 怎么使用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#hook-使用约束" class="router-link-active router-link-exact-active sidebar-item" aria-label="Hook 使用约束"><!--[--><!--]--> Hook 使用约束 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#hooks-怎么实现-class-组件的功能" class="router-link-active router-link-exact-active sidebar-item" aria-label="Hooks 怎么实现 class 组件的功能"><!--[--><!--]--> Hooks 怎么实现 class 组件的功能 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#如何强制更新-hook-组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="如何强制更新 Hook 组件?"><!--[--><!--]--> 如何强制更新 Hook 组件? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#类实例成员变量如何映射到-hooks" class="router-link-active router-link-exact-active sidebar-item" aria-label="类实例成员变量如何映射到 Hooks?"><!--[--><!--]--> 类实例成员变量如何映射到 Hooks? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#hook-中如何获取旧的-props-和-state" class="router-link-active router-link-exact-active sidebar-item" aria-label="Hook 中如何获取旧的 props 和 state"><!--[--><!--]--> Hook 中如何获取旧的 props 和 state <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#redux" class="router-link-active router-link-exact-active sidebar-item" aria-label="Redux"><!--[--><!--]--> Redux <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/front-end-lab/topic/react.html#什么场景会考虑使用状态管理器" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么场景会考虑使用状态管理器"><!--[--><!--]--> 什么场景会考虑使用状态管理器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#redux-是什么-它遵循什么原则吗" class="router-link-active router-link-exact-active sidebar-item" aria-label="redux 是什么? 它遵循什么原则吗?"><!--[--><!--]--> redux 是什么? 它遵循什么原则吗? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#描述-redux-单向数据流" class="router-link-active router-link-exact-active sidebar-item" aria-label="描述 redux 单向数据流"><!--[--><!--]--> 描述 redux 单向数据流 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><a href="/front-end-lab/topic/vue.html" class="sidebar-item" aria-label="Vue.js"><!--[--><!--]--> Vue.js <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading">优化与原理解析 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/front-end-lab/topic/browser.html" class="sidebar-item" aria-label="浏览器工作原理"><!--[--><!--]--> 浏览器工作原理 <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/performance.html" class="sidebar-item" aria-label="应用优化"><!--[--><!--]--> 应用优化 <!--[--><!--]--></a><!----></li><li><a href="/front-end-lab/topic/network.html" class="sidebar-item" aria-label="网络原理"><!--[--><!--]--> 网络原理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/front-end-lab/topic/complex.html" class="sidebar-item sidebar-heading" aria-label="综合"><!--[--><!--]--> 综合 <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h1><p><img src="/front-end-lab/assets/react.fac2d9b8.jpg" alt="react cover"></p><nav class="table-of-contents"><ul><li><a aria-current="page" href="/front-end-lab/topic/react.html#基础概念" class="router-link-active router-link-exact-active">基础概念</a><ul><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-是单向数据流还是双向数据流-它还有其他特点吗" class="router-link-active router-link-exact-active">React 是单向数据流还是双向数据流？它还有其他特点吗？</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-通过什么方式来更新数据" class="router-link-active router-link-exact-active">React 通过什么方式来更新数据</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-不能直接修改-state-吗" class="router-link-active router-link-exact-active">React 不能直接修改 State 吗？</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#setstate-是同步还是异步的" class="router-link-active router-link-exact-active">setState 是同步还是异步的？</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#函数组件是什么-与类组件有什么区别" class="router-link-active router-link-exact-active">函数组件是什么？与类组件有什么区别？</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#受控组件与非受控组件的区别" class="router-link-active router-link-exact-active">受控组件与非受控组件的区别</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react中的合成事件是什么" class="router-link-active router-link-exact-active">React中的合成事件是什么？</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#为什么浏览器无法读取jsx" class="router-link-active router-link-exact-active">为什么浏览器无法读取JSX？</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#jsx-是如何编译为-js-代码的" class="router-link-active router-link-exact-active">JSX 是如何编译为 js 代码的？</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-生命周期" class="router-link-active router-link-exact-active">React 生命周期</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-组件通信" class="router-link-active router-link-exact-active">React 组件通信</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-context-怎么使用" class="router-link-active router-link-exact-active">React.Context 怎么使用</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-怎么做代码复用" class="router-link-active router-link-exact-active">React 怎么做代码复用</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#高阶函数、高阶组件是什么" class="router-link-active router-link-exact-active">高阶函数、高阶组件是什么？</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#怎么对组件的参数做类型约束呢" class="router-link-active router-link-exact-active">怎么对组件的参数做类型约束呢?</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#组件设计原则" class="router-link-active router-link-exact-active">组件设计原则</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#渲染与优化" class="router-link-active router-link-exact-active">渲染与优化</a><ul><li><a aria-current="page" href="/front-end-lab/topic/react.html#渲染列表为啥要用-key" class="router-link-active router-link-exact-active">渲染列表为啥要用 key？</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#虚拟-dom-是如何提升性能的" class="router-link-active router-link-exact-active">虚拟 dom 是如何提升性能的</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-在虚拟-dom-的-diff-上-做了哪些改进使得速度很快" class="router-link-active router-link-exact-active">react 在虚拟 dom 的 diff 上，做了哪些改进使得速度很快?</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-diffing-算法概述" class="router-link-active router-link-exact-active">React Diffing 算法概述</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-diffing-算法的时间复杂度和空间复杂度" class="router-link-active router-link-exact-active">React Diffing 算法的时间复杂度和空间复杂度</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#react-如何做性能优化" class="router-link-active router-link-exact-active">React 如何做性能优化</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#父组件在执行-render-时会不会触发子组件的-render-事件-如果会该怎么避免" class="router-link-active router-link-exact-active">父组件在执行 render 时会不会触发子组件的 render 事件？如果会该怎么避免？</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#什么是-portals" class="router-link-active router-link-exact-active">什么是 Portals?</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#什么是-react-fiber" class="router-link-active router-link-exact-active">什么是 React Fiber?</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#说说-fiber-架构是怎么实现的" class="router-link-active router-link-exact-active">说说 Fiber 架构是怎么实现的</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#fiber-和-stack-的区别" class="router-link-active router-link-exact-active">Fiber 和 Stack 的区别</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#异步组件怎么使用" class="router-link-active router-link-exact-active">异步组件怎么使用？</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#hooks" class="router-link-active router-link-exact-active">Hooks</a><ul><li><a aria-current="page" href="/front-end-lab/topic/react.html#hooks-相比-class-的优点" class="router-link-active router-link-exact-active">Hooks 相比 class 的优点</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#hooks-的使用" class="router-link-active router-link-exact-active">Hooks 的使用</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#自定义-hook-怎么使用" class="router-link-active router-link-exact-active">自定义 Hook 怎么使用</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#hook-使用约束" class="router-link-active router-link-exact-active">Hook 使用约束</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#hooks-怎么实现-class-组件的功能" class="router-link-active router-link-exact-active">Hooks 怎么实现 class 组件的功能</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#如何强制更新-hook-组件" class="router-link-active router-link-exact-active">如何强制更新 Hook 组件?</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#类实例成员变量如何映射到-hooks" class="router-link-active router-link-exact-active">类实例成员变量如何映射到 Hooks?</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#hook-中如何获取旧的-props-和-state" class="router-link-active router-link-exact-active">Hook 中如何获取旧的 props 和 state</a></li></ul></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#redux" class="router-link-active router-link-exact-active">Redux</a><ul><li><a aria-current="page" href="/front-end-lab/topic/react.html#什么场景会考虑使用状态管理器" class="router-link-active router-link-exact-active">什么场景会考虑使用状态管理器</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#redux-是什么-它遵循什么原则吗" class="router-link-active router-link-exact-active">redux 是什么? 它遵循什么原则吗?</a></li><li><a aria-current="page" href="/front-end-lab/topic/react.html#描述-redux-单向数据流" class="router-link-active router-link-exact-active">描述 redux 单向数据流</a></li></ul></li></ul></nav><h2 id="基础概念" tabindex="-1"><a class="header-anchor" href="#基础概念" aria-hidden="true">#</a> 基础概念</h2><h3 id="react-是单向数据流还是双向数据流-它还有其他特点吗" tabindex="-1"><a class="header-anchor" href="#react-是单向数据流还是双向数据流-它还有其他特点吗" aria-hidden="true">#</a> React 是单向数据流还是双向数据流？它还有其他特点吗？</h3><ul><li>React 是单向数据流，数据是从上向下流</li><li>声明式编写 UI</li><li>组件化开发</li></ul><hr><h3 id="react-通过什么方式来更新数据" tabindex="-1"><a class="header-anchor" href="#react-通过什么方式来更新数据" aria-hidden="true">#</a> React 通过什么方式来更新数据</h3><p>React 是通过 <code>setState</code> 来更新数据的。调用多个 <code>setState</code> 不会立即更新数据，而是批量延迟更新后再将数据合并。</p><p>除了 <code>setState</code> 外还可以使用 <code>forceUpdate</code> 跳过当前组件的 <code>shouldComponentUpdate</code> 对比，强制触发组件渲染(避免使用该方式)。</p><hr><h3 id="react-不能直接修改-state-吗" tabindex="-1"><a class="header-anchor" href="#react-不能直接修改-state-吗" aria-hidden="true">#</a> React 不能直接修改 State 吗？</h3><ol><li>直接修改 state 不会触发组件的渲染。</li><li>若直接修改 state 引用的值，在实际使用时会导致错误的值出现</li><li>修改后的 state 可能会被后续调用的 <code>setState</code> 覆盖</li></ol><hr><h3 id="setstate-是同步还是异步的" tabindex="-1"><a class="header-anchor" href="#setstate-是同步还是异步的" aria-hidden="true">#</a> setState 是同步还是异步的？</h3><p>出于性能的考虑，可能会把多个 <code>setState</code> 合并成一个调用。</p><p>在 React 控制的生命周期、React 封装的事件处理器中直接使用是异步的(命中 <code>batchUpdate</code> 机制，<code>isBatchingUpdate</code> 的标志位为 <code>true</code>)。比如 React中注册的 <code>onClick</code> 事件或是 <code>componentDidMount</code> 中直接使用都是异步的。</p><p>可以给 <code>setState</code> 第二个参数传递一个函数，该函数是<strong>数据更新后会触发的回调函数</strong>。在该函数中可以拿到更新后最新的值。</p><p>在 React 控制外中使用 <code>setState</code> 是同步的，比如在 <code>setTimeout</code>, 或者是原生的事件监听器中使用都是同步的。</p><hr><h3 id="函数组件是什么-与类组件有什么区别" tabindex="-1"><a class="header-anchor" href="#函数组件是什么-与类组件有什么区别" aria-hidden="true">#</a> 函数组件是什么？与类组件有什么区别？</h3><p>函数组件本质上是一个纯函数，它接受 props 属性，最后返回 JSX。</p><p>与类组件的差别在于: 它没有实例、不能通过 <code>extends</code> 继承于其他方法、也没有生命周期和 <code>state</code>(但可以引入 <code>Hooks</code> 来处理没有生命周期和 <code>state</code> 的问题)。</p><hr><h3 id="受控组件与非受控组件的区别" tabindex="-1"><a class="header-anchor" href="#受控组件与非受控组件的区别" aria-hidden="true">#</a> 受控组件与非受控组件的区别</h3><p>受控组件主要是指表单的值受到 <code>state</code> 的控制，它需要自行监听 <code>onChange</code> 事件来更新 <code>state</code>。</p><p>由于受控组件每次都要编写事件处理器才能更新 <code>state</code> 数据、可能会有点麻烦，React 提供另一种代替方案是<strong>非受控组件</strong>。</p><p>非受控组件将<strong>真实数据储存在 DOM 节点</strong>中,它可以为表单项设置默认值，不需要手动更新数据。当需要用到表单数据时再通过 <code>ref</code> 从 DOM 节点中取出数据即可。</p><p><strong>注意: 多数情况下React 推荐编写受控组件。</strong></p><p>扩展资料: <a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/" target="_blank" rel="noopener noreferrer">受控和非受控制使用场景的选择<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a></p><hr><h3 id="react中的合成事件是什么" tabindex="-1"><a class="header-anchor" href="#react中的合成事件是什么" aria-hidden="true">#</a> React中的合成事件是什么？</h3><p>合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。</p><hr><h3 id="为什么浏览器无法读取jsx" tabindex="-1"><a class="header-anchor" href="#为什么浏览器无法读取jsx" aria-hidden="true">#</a> 为什么浏览器无法读取JSX？</h3><p>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。</p><hr><h3 id="jsx-是如何编译为-js-代码的" tabindex="-1"><a class="header-anchor" href="#jsx-是如何编译为-js-代码的" aria-hidden="true">#</a> JSX 是如何编译为 js 代码的？</h3><p>在 React v17 之前，JSX 会被编译为 <code>React.createElement(component, props, ...children)</code> 函数，执行会返回 <code>vnode</code>，<code>vnode</code> 通过 <code>patch</code> 之类的方法渲染到页面。</p><p>React v17 之后更新了 JSX 转换规则。新的 JSX 转换不会将 JSX 转换为 <code>React.createElement</code>，而是自动从 React 的 <code>package</code> 中引入新的入口函数(<code>react/jsx-runtime</code>)并调用。这意味着我们不用在每个组件文件中显式引入 <code>React</code>。</p><hr><h3 id="react-生命周期" tabindex="-1"><a class="header-anchor" href="#react-生命周期" aria-hidden="true">#</a> React 生命周期</h3><p>针对 React 生命周期中函数的调用顺序，笔者写了一个简易的 Demo 用于演示: <a href="https://codesandbox.io/s/react-lifecycle-forked-2dvdg?file=/src/Parent.jsx" target="_blank" rel="noopener noreferrer">React 父子组件生命周期示例<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a></p><p><strong>React 组件挂载阶段</strong>先后会触发 <code>constuctor</code>、<code>static getDerivedStateFromProps</code>、<code>render</code>、<code>componentDidMount</code> 函数。若 <code>render</code> 函数内还有子组件存在的话，则会进一步递归:</p><div class="language-log ext-log line-numbers-mode"><pre class="language-log"><code>[Parent]: constuctor
[Parent]: static getDerivedStateFromProps
[Parent]: render
[Children]: constuctor
[Children]: static getDerivedStateFromProps
[Children]: render
[Children]: componentDidMount
[Children]: 挂载阶段结束!
[Parent]: componentDidMount
[Parent]: 挂载阶段结束!
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>React 组件更新阶段</strong>：主要是组件的 props 或 state 发生变化时触发。若组件内还有子组件，则子组件会判断是否也需要触发更新。默认情况下 <code>component</code> 组件是只要父组件发生了变化，子组件也会跟着变化。以下是更新父组件 <code>state</code> 数据时所触发的生命周期函数:</p><div class="language-log ext-log line-numbers-mode"><pre class="language-log"><code>[Parent]: static getDerivedStateFromProps
[Parent]: shouldComponentUpdate
[Parent]: render
[Children]: static getDerivedStateFromProps
[Children]: shouldComponentUpdate
[Children]: render
[Children]: getSnapshotBeforeUpdate
[Parent]: getSnapshotBeforeUpdate
[Children]: componentDidUpdate
[Children]: 更新阶段结束!
[Parent]: componentDidUpdate
[Parent]: 更新阶段结束!
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>React 组件销毁阶段</strong>：父组件先触发销毁前的函数，再逐层向下触发:</p><div class="language-log ext-log line-numbers-mode"><pre class="language-log"><code>[Parent]: componentWillUnmount
[Parent]: 卸载阶段结束!
[Children]: componentWillUnmount
[Children]: 卸载阶段结束!
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr><h3 id="react-组件通信" tabindex="-1"><a class="header-anchor" href="#react-组件通信" aria-hidden="true">#</a> React 组件通信</h3><ul><li>父组件通过 props 给子组件传参，子组件通过触发父组件提供的回调函数来给父组件传递数据</li><li>React.Context</li><li>自定义事件</li><li>redux/mobx 之类的状态管理器</li></ul><hr><h3 id="react-context-怎么使用" tabindex="-1"><a class="header-anchor" href="#react-context-怎么使用" aria-hidden="true">#</a> React.Context 怎么使用</h3><p><code>Context</code> 可以共享对于组件树而言是全局的数据，比如全局主题、首选语言等。使用方式如下：</p><ol><li><p><code>React.createContext</code> 函数用于生成 <code>Context</code> 对象。可以在创建时给 <code>Context</code> 设置默认值：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const ThemeContext = React.createContext(&quot;light&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p><code>Context</code> 对象中有一个 <code>Provider(提供者)</code> 组件，<code>Provider</code> 组件接受一个 <code>value</code> 属性用以将数据传递给消费组件。</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code>&lt;ThemeContext.Provider value=&quot;dark&quot;&gt;
  &lt;page /&gt;
&lt;/ThemeContext.Provider&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>获取 <code>Context</code> 提供的值可以通过 <code>contextType</code> 或者 <code>Consumer(消费者)</code> 组件中获取。<code>contextType</code> 只能用于类组件，并且只能挂载一个 <code>Context</code>：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>class MyClass extends React.Component {
  componentDidMount() {
    let value = this.context;
    /* 在组件挂载完成后，使用 MyContext 的值执行一些有副作用的操作 */
  }
  render() {
    let value = this.context;
    /* 基于 MyContext 的值进行渲染 */
  }
}
MyClass.contextType = MyContext;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>若想给组件挂载多个 <code>Context</code>, 或者在函数组件内使用 <code>Context</code> 可以使用 <code>Consumer</code> 组件:</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code>&lt;ThemeContext.Consumer&gt;
  {(theme) =&gt; (
    &lt;UserContext.Consumer&gt;
      {(user) =&gt; &lt;ProfilePage user={user} theme={theme} /&gt;}
    &lt;/UserContext.Consumer&gt;
  )}
&lt;/ThemeContext.Consumer&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ol><p><code>Context</code> 通常适用于传递较为简单的数据信息，若数据太过复杂，还是需要引入状态管理(redux/mbox)。</p><hr><h3 id="react-怎么做代码复用" tabindex="-1"><a class="header-anchor" href="#react-怎么做代码复用" aria-hidden="true">#</a> React 怎么做代码复用</h3><ul><li><a href="https://react.html.cn/docs/render-props.html" target="_blank" rel="noopener noreferrer">Render Props<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a></li><li>高阶组件 (HOC)</li><li>自定义 Hooks</li><li>Mixins (已被 React 废弃的方案)</li></ul><p><code>Render props</code> 是一种在 React 组件之间共享代码的简单技术。具体的行为是:</p><ol><li>子组件接收一个用于渲染指定视图的 <code>prop</code> 属性，该属性的类型是函数。</li><li>父组件在组件内部定义该函数后，将函数的引入传给子组件</li><li>子组件将组件内部 <code>state</code> 作为实参传给从外面传来的函数，并将函数的返回结果渲染在指定的视图区域。</li></ol><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code>// 组件使用
&lt;Mouse
  render={(x, y) =&gt; (
    &lt;span&gt;
      x: {x}, y: {y}
    &lt;/span&gt;
  )}
/&gt;;

// 组件内部大致实现
class Mouse extends React.Component {
  state = { x: 0, y: 0 };

  render() {
    return (
      &lt;section&gt;
        &lt;header&gt;头部信息&lt;/header&gt;
        &lt;main&gt;{this.props.render(this.state)}&lt;/main&gt;
        &lt;footer&gt;底部信息&lt;/footer&gt;
      &lt;/section&gt;
    );
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>准确来说 <code>Render props</code> 是一个用于告知组件需要渲染什么内容的函数属性。<code>props</code> 的命名可以由自己定义，比如用于在内容区域渲染的 prop 名可以叫 <code>render</code>，同时还可以再接收一个 <code>renderHead</code> 的 prop 用于渲染头部的信息。</p><hr><h3 id="高阶函数、高阶组件是什么" tabindex="-1"><a class="header-anchor" href="#高阶函数、高阶组件是什么" aria-hidden="true">#</a> 高阶函数、高阶组件是什么？</h3><p><strong>高阶函数</strong>就是<strong>接收其它函数作为参数</strong>的函数就称之为高阶函数，像数组的 <code>map</code> 、<code>sort</code>、<code>filter</code> 都是高阶函数。</p><p><strong>高阶组件(Higher-order component, HOC)</strong> 是 React 用于复用组件逻辑的一种高级技巧。它具体的行为是：</p><p>函数<strong>接收一个组件作为参数</strong>，在函数体内<strong>定义一个新组件</strong>，新组件内<strong>编写可复用的逻辑</strong>并应用到参数组件中。最后再将<strong>新组件作为函数的返回值</strong> return 出去。 <code>redux</code> 中的 <code>connect</code> 函数就是一个高阶组件。</p><hr><h3 id="怎么对组件的参数做类型约束呢" tabindex="-1"><a class="header-anchor" href="#怎么对组件的参数做类型约束呢" aria-hidden="true">#</a> 怎么对组件的参数做类型约束呢?</h3><p>要对组件的参数做类型约束的话，可以引入 <code>prop-types</code> 来配置对应的 <code>propTypes</code> 属性。 <code>Flow</code> 和 <code>TypesScript</code> 则可以对整个应用做类型检查。</p><hr><h3 id="组件设计原则" tabindex="-1"><a class="header-anchor" href="#组件设计原则" aria-hidden="true">#</a> 组件设计原则</h3><ul><li>从功能上拆分组件</li><li>组件功能原子化</li><li>容器组件只管数据，UI 组件只管视图</li><li>可复用、易用、直观</li><li>组件库可以遵循 <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles" target="_blank" rel="noopener noreferrer">ARIA<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a> 规范</li></ul><h2 id="渲染与优化" tabindex="-1"><a class="header-anchor" href="#渲染与优化" aria-hidden="true">#</a> 渲染与优化</h2><h3 id="渲染列表为啥要用-key" tabindex="-1"><a class="header-anchor" href="#渲染列表为啥要用-key" aria-hidden="true">#</a> 渲染列表为啥要用 key？</h3><p>在渲染列表时，为列表子项指定唯一的 <code>key</code> 是非常重要的。如果不为列表子项提供 <code>key</code>，React 将默认使用 <code>index</code> 作为 <code>key</code>，同时会在控制台发出警告。</p><p><code>key</code> 在兄弟节点之间必须唯一，应避免使用数组下标 <code>index</code> 作为 <code>key</code>。因为使用数组下标作为 <code>key</code> 可能会导致一些问题：</p><ul><li>当列表的顺序发生改变时，React 可能会错误地重新排序或重渲染列表中的元素，从而影响页面的稳定性和性能。</li><li>对于列表中的组件，组件实例是基于 <code>key</code> 来决定是否更新与复用的。当顺序发生变化时，<code>key</code> 也会相应变化，可能导致子组件间的数据错乱或状态丢失。</li></ul><p>React 的 Diffing 算法是通过 <code>tag</code> 和 <code>key</code> 判断是否是同一个元素(<code>sameNode</code>)，因此使用唯一的 <code>key</code> 有助于 React 识别哪些元素发生了改变，如节点添加或删除，从而减少不必要的 DOM 操作，优化性能。</p><p>如果列表项中的数据没有唯一的标识符，可以使用第三方库比如 <a href="https://www.npmjs.com/package/shortid" target="_blank" rel="noopener noreferrer">shortid<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a> 来生成唯一的 <code>id</code>：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>const shortid = require(&quot;shortid&quot;);

function addId(data) {
  return {
    ...data,
    id: shortid.generate(),
  };
}

const newList = list.map(addId);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>若确定没有列表的顺序不会发生变化同时没有其他唯一的 <code>key</code> 来标识列表项时才能使用数组的下标。</p><hr><h3 id="虚拟-dom-是如何提升性能的" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-是如何提升性能的" aria-hidden="true">#</a> 虚拟 dom 是如何提升性能的</h3><p>当组件触发更新时，虚拟 DOM 通过比对新旧 <code>state</code> 和 <code>props</code> 的变化以决定是否渲染 DOM 节点，从而减少渲染提升性能。因为修改真实 DOM 所耗费的性能远比操作 JavaScript 多几倍，因此使用虚拟 DOM 在渲染性能上会高效的多。</p><hr><h3 id="react-在虚拟-dom-的-diff-上-做了哪些改进使得速度很快" tabindex="-1"><a class="header-anchor" href="#react-在虚拟-dom-的-diff-上-做了哪些改进使得速度很快" aria-hidden="true">#</a> react 在虚拟 dom 的 diff 上，做了哪些改进使得速度很快?</h3><ol><li><p><strong>Fiber 架构</strong>：</p><ul><li>React 16 引入了 Fiber 架构，重写了 React 的内部机制。Fiber 允许 React 进行增量渲染——即将渲染任务分解为多个小任务，并且可以中断和恢复这些任务。这种方式让 React 在处理大型更新时更为高效，可以更好地利用浏览器的帧率。</li></ul></li><li><p><strong>优先级调度</strong>：</p><ul><li>Fiber 架构引入了任务优先级的概念，允许 React 根据更新的紧急性分配不同的优先级。这意味着 React 可以优先完成更重要的更新，例如与用户交互相关的更新。</li></ul></li><li><p><strong>Reconciliation 算法优化</strong>：</p><ul><li>React 在进行组件树比较时，会优化对子组件的比较。如果组件类型相同，React 会假设结构没有发生大的变化，只进行属性的比较和更新。使用 <code>key</code> 可以帮助 React 确定哪些元素需要更新、移动或删除，减少不必要的组件重渲染。</li></ul></li><li><p><strong>跳过不必要的比较</strong>：</p><ul><li>使用 <code>React.memo</code> 和 <code>shouldComponentUpdate</code> 等 API，开发者可以指定在何种情况下组件不需要进行重新渲染，减少了不必要的 diff 和重渲染过程。</li></ul></li></ol><hr><h3 id="react-diffing-算法概述" tabindex="-1"><a class="header-anchor" href="#react-diffing-算法概述" aria-hidden="true">#</a> React Diffing 算法概述</h3><p>React 使用名为 <code>Reconciliation</code> 的算法来优化虚拟DOM的更新过程。算法的核心在于比较两个根元素及其子元素的变化，具体流程如下：</p><ol><li><p><strong>节点类型变化</strong>：</p><ul><li>当节点类型发生变化时，React 将卸载旧树并构建新树。例如，从 <code>&lt;div&gt;</code> 变为 <code>&lt;section&gt;</code> 会导致节点及其子节点的重新渲染。</li></ul></li><li><p><strong>DOM 节点类型相同</strong>：</p><ul><li>如果 DOM 节点类型未改变，React 仅更新发生变化的属性，保留原节点。</li></ul></li><li><p><strong>组件类型相同</strong>：</p><ul><li>对于组件，如果类型相同，React 将保持组件实例不变，更新 props，并调用生命周期方法 <code>static getDerivedStateFromProps()</code> 和 <code>componentDidUpdate()</code>。之后会调用 <code>render</code> 方法，如果包含子组件，则递归触发 Diff。</li></ul></li><li><p><strong>列表节点变化检查</strong>：</p><ul><li><strong>未设置 key</strong>：逐个对比节点，新元素若在列表中间出现，则从该位置起丢弃所有后续节点并重新渲染。</li><li><strong>设置了 key</strong>：通过 key 快速匹配新旧节点间的关系，有效避免不必要的节点重渲染。</li></ul></li></ol><p><img src="/front-end-lab/assets/reconciliation.2b55b6af.png" alt="React Reconciliation"></p><hr><h3 id="react-diffing-算法的时间复杂度和空间复杂度" tabindex="-1"><a class="header-anchor" href="#react-diffing-算法的时间复杂度和空间复杂度" aria-hidden="true">#</a> React Diffing 算法的时间复杂度和空间复杂度</h3><p>React 的 Diffing 算法设计用于高效比较两棵虚拟DOM树，以最小化更新实际 DOM 的成本。算法的复杂度如下：</p><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，其中 <code>n</code> 是树中的节点数。React 通过限制只在同一层级节点间进行比较，从而实现线性时间复杂度。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，主要存储维护旧树和新树的节点信息及比较过程中需要的额外空间。</li></ul><p>React 的 Diffing 算法通过假设和优化（如同层比较、类型检查）显著提高了界面更新的效率。</p><hr><h3 id="react-如何做性能优化" tabindex="-1"><a class="header-anchor" href="#react-如何做性能优化" aria-hidden="true">#</a> React 如何做性能优化</h3><ol><li><p><code>props/state</code> 新旧值的变化来决定是否渲染组件。</p><p>React 可以通过 <code>shouldComponentUpdate</code>, <code>PureComponent</code>, <code>React.memo</code> 来对组件渲染进行性能优化。</p><p><code>shouldComponentUpdate</code> 是 class 组件生命周期中的一个钩子，常用于 <code>component</code> 中。</p><p>该钩子的返回值可以决定组件是否进行渲染，如果没有在组件内定义该钩子的逻辑，则默认返回 <code>true</code>, 这也就意味着 React 默认情况下是无条件渲染的。通常 <code>component</code> 组件可以通过该钩子对比数据，以决定组件是否该渲染，从而避免重复渲染的问题。</p><blockquote><p>值得注意的是，即便在 <code>shouldComponentUpdate</code> 对新旧 props 使用深对比也不能破坏 React **不可变值****不可变值**原值。 因为直接改变 state 的数据再通过 setState 来更新数据，因为新旧数据的值是一致的(旧数据被修改)，也就不能触发渲染。</p></blockquote></li><li><p>列表渲染时每项添加唯一的 <code>key</code>。</p></li><li><p>定时器、DOM 事件等在组件销毁时一同销毁，从而避免内存泄露。</p></li><li><p>代码分割，使用异步组件。</p></li><li><p>Hooks 使用 <code>useMemo</code> 缓存上一次计算的结果，避免重复计算值。</p></li></ol><hr><h3 id="父组件在执行-render-时会不会触发子组件的-render-事件-如果会该怎么避免" tabindex="-1"><a class="header-anchor" href="#父组件在执行-render-时会不会触发子组件的-render-事件-如果会该怎么避免" aria-hidden="true">#</a> 父组件在执行 render 时会不会触发子组件的 render 事件？如果会该怎么避免？</h3><p>如果父组件渲染后，子组件接收的 props 也跟着发生了改变，那么默认情况下会触发子组件的渲染。</p><p>若子组件接收的 props 没有发生改变，那就得判断子组件的状况。</p><p>如果子组件是继承于 <code>component</code> 声明的组件，并且没有使用 <code>shouldComponentUpdate</code> 做避免重复渲染的处理，那么子组件会触发 render 事件。</p><p>为了避免重复渲染，类组件可以使用 <code>shouldComponentUpdate</code> 来决定是否进行渲染。也可以将继承于 <code>component</code> 组件改为继承 <code>PureComponment</code>，该组件会浅对比 <code>Props</code> 是否进行改变，从而决定是否渲染组件。</p><p>如果是函数组件，可以通过 <code>React.memo</code> 来对函数组件进行缓存。</p><blockquote><p>问题本质上想问 React 性能优化的问题，可以参考上题答案。</p></blockquote><hr><h3 id="什么是-portals" tabindex="-1"><a class="header-anchor" href="#什么是-portals" aria-hidden="true">#</a> 什么是 Portals?</h3><p><code>Portals</code> 就像个传送门，它可以将子节点渲染到存在于父组件以外的 DOM 节点的方案。</p><p>比如 <code>Dialog</code> 是一个全局组件，按照传统渲染组件的方式，<code>Dialog</code> 可能会受到其容器 css 的影响。因此可以使用 <code>Portals</code> 让组件在视觉上渲染到 <code>&lt;body&gt;</code> 中，使其样式不受 <code>overflow: hidden</code> 或 <code>z-index</code> 的影响。</p><hr><h3 id="什么是-react-fiber" tabindex="-1"><a class="header-anchor" href="#什么是-react-fiber" aria-hidden="true">#</a> 什么是 React Fiber?</h3><p>Fiber 是 React 16 中新的<strong>协调引擎或重新实现核心算法</strong>。它的主要目标是<strong>支持虚拟 DOM 的增量渲染</strong>。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。</p><p>它的主要特性是增量渲染: 能够将渲染工作分割成块，并将其分散到多个帧中。</p><hr><h3 id="说说-fiber-架构是怎么实现的" tabindex="-1"><a class="header-anchor" href="#说说-fiber-架构是怎么实现的" aria-hidden="true">#</a> 说说 Fiber 架构是怎么实现的</h3><p>React Fiber 通过引入新的内部架构和调度机制，使 React 能够更有效地处理 UI 更新。Fiber 架构的核心在于：</p><ol><li><strong>Fiber 数据结构</strong>：每个组件有一个对应的 Fiber 对象，代表一个工作单元，包含组件的状态、props 和 DOM 节点引用。</li><li><strong>双缓冲技术</strong>：React 维护两棵树，一棵当前显示的树和一棵正在构建的树，使得 UI 更新可以异步并且无干扰地进行。</li><li><strong>增量渲染</strong>：React 可以将更新任务拆分为多个小任务，并根据优先级异步执行，从而不会阻塞主线程。</li><li><strong>任务中断与恢复</strong>：React 可以根据需要中断和恢复更新任务，优先处理更重要的任务，如用户交互。</li></ol><hr><h3 id="fiber-和-stack-的区别" tabindex="-1"><a class="header-anchor" href="#fiber-和-stack-的区别" aria-hidden="true">#</a> Fiber 和 Stack 的区别</h3><p>React Fiber 和 React Stack 是 React 的两个不同的渲染引擎版本。Stack 是在 Fiber 引入之前使用的旧版同步渲染引擎。它们的主要区别：</p><ol><li><p><strong>渲染方法</strong>：</p><ul><li><strong>Stack</strong>：使用递归的渲染方法，无法中断，可能导致长时间的UI阻塞。</li><li><strong>Fiber</strong>：使用可以中断的任务分割方法，提高应用响应性和渲染效率。</li></ul></li><li><p><strong>任务调度与优先级</strong>：</p><ul><li><strong>Stack</strong>：没有任务优先级，更新按发生顺序同步执行。</li><li><strong>Fiber</strong>：支持优先级调度，能够优先处理更重要的任务，提升交互体验。</li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li><strong>Stack</strong>：错误可能导致整个应用崩溃。</li><li><strong>Fiber</strong>：引入错误边界，允许局部捕获和处理错误。</li></ul></li><li><p><strong>并发模式</strong>：</p><ul><li><strong>Stack</strong>：不支持并发模式。</li><li><strong>Fiber</strong>：为真正的并发模式和更好的任务管理奠定基础。</li></ul></li></ol><hr><h3 id="异步组件怎么使用" tabindex="-1"><a class="header-anchor" href="#异步组件怎么使用" aria-hidden="true">#</a> 异步组件怎么使用？</h3><ol><li><p>通过动态 <code>import()</code> 语法对组件代码进行分割。</p></li><li><p>使用 <code>React.lazy</code> 函数，结合 <code>import()</code> 语法引入动态组件。在组件首次渲染时，会自动导入包含 <code>MyComponent</code> 的包。</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code>const MyComponent = React.lazy(() =&gt; import(&quot;./MyComponent&quot;));
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p>在 <code>React.Suspense</code> 组件中渲染 <code>lazy</code> 组件，同时可以使用 <code>fallback</code> 做优雅降级(添加 <code>loading</code> 效果):</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code>&lt;React.Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
  &lt;MyComponent /&gt;
&lt;/React.Suspense&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>封装一个错误捕获组件(比如组件命名为 <code>MyErrorBoundary</code>)，组件内通过生命周期 <code>getDerivedStateFromError</code> 捕获错误信息。当异步组件加载失败时，将捕获到错误信息处理后给用户做错误提示功能。</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code>&lt;MyErrorBoundary&gt;
  &lt;React.Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
    &lt;MyComponent /&gt;
  &lt;/React.Suspense&gt;
&lt;/MyErrorBoundary&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol><hr><h2 id="hooks" tabindex="-1"><a class="header-anchor" href="#hooks" aria-hidden="true">#</a> Hooks</h2><h3 id="hooks-相比-class-的优点" tabindex="-1"><a class="header-anchor" href="#hooks-相比-class-的优点" aria-hidden="true">#</a> Hooks 相比 class 的优点</h3><p>类组件的不足:</p><ul><li>状态逻辑复用难，缺少复用机制。渲染属性和高阶组件导致层级冗余</li><li>复杂组件变得难以理解</li><li>this 指向困扰</li></ul><p>Hooks 的优点:</p><ul><li>自定义 Hook 方便复用状态逻辑</li><li>副作用的关注点分离</li><li>函数组件没有 this 问题</li></ul><p>Hooks 现有的不足:</p><ul><li>不能完全代替 class 组件的生命周期，部分不常用的生命周期暂时没有实现</li><li>useEffect 等 Hook 的运作方式带来了一定的学习成本，需要转换现有的编程思维</li></ul><hr><h3 id="hooks-的使用" tabindex="-1"><a class="header-anchor" href="#hooks-的使用" aria-hidden="true">#</a> Hooks 的使用</h3><blockquote><p>描述 Hooks 有哪些方法和大致用途</p></blockquote><ol><li><p><code>useState</code>: 使函数组件支持设置 <code>state</code> 数据，可用于代替类组件的 <code>constructor</code> 函数。</p></li><li><p><code>useEffect</code>: 使函数组件支持操作副作用的能力，可以模拟类组件 <code>componentDidMount</code> 的功能。同时还能监听数据变化，进而操作一系列诸如数据获取等副作用操作。 可以在 <code>useEffect</code> 的函数中返回一个函数做清除操作。这个清除操作时可选的:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>// 第一个参数是函数
// 第二个参数是函数内所依赖的外部变量数组。若没有外部依赖，则可以忽略第二个参数。
useEffect(() =&gt; {
  document.addEventListener(&quot;click&quot;, handleClick);

  // useEffect 回调函数的返回值是函数的话，当组件卸载时会执行该函数
  // 若没有需要清除的东西，则可以忽略这一步骤
  return () =&gt; {
    document.removeEventListener(&quot;click&quot;, handleClick);
  };
}, [handleClick]);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li><li><p><code>useContext</code>: 接收一个 <code>Context</code> 对象，并返回 <code>Context</code> 的当前值。相当于类组件的 <code>static contextType = MyContext</code>。</p></li><li><p><code>useReducer</code> 是 <code>useState</code> 的代替方案，有点类似于 <code>redux</code> 的工作方式。它通过函数来操作 state，适合 state 逻辑较为复杂且包含多个子值，或是下一个 state 依赖于旧的 state 的场景。</p></li><li><p><code>useMemo</code> 可以缓存变量的值，避免每次组件更新后都需要重复计算值。</p></li><li><p><code>useCallbck</code> 用于缓存函数，避免函数被重复创建。它是 <code>useMemo</code> 的语法糖，<code>useCallback(fn, deps)</code> 相当于是 <code>useMemo(() =&gt; fn, deps)</code>。</p></li></ol><hr><h3 id="自定义-hook-怎么使用" tabindex="-1"><a class="header-anchor" href="#自定义-hook-怎么使用" aria-hidden="true">#</a> 自定义 Hook 怎么使用</h3><p>自定义 Hook 的命名规则是以 <code>use</code> 开头的函数，比如 <code>useLocalStorage</code> 就符合自定义 Hook 的命名规范。 使用自定义 Hook 的场景有很多，如表单处理、动画、订阅声明、定时器等等可复用的逻辑都能通过自定义 Hook 来抽象实现。</p><p>在自定义 Hook 中，可以使用 Hooks 函数将可复用的逻辑和功能提取出来，并将内部的 <code>state</code> 或操作的方法从自定义 Hook 函数中返回出来。函数组件使用时就可以像调用普通函数一祥调用自定义 Hook 函数, 并将自定义 Hook 返回的 <code>state</code> 和操作方法通过解构保存到变量中。</p><p>下面是 <a href="https://usehooks.com/useLocalStorage/" target="_blank" rel="noopener noreferrer">useLocalStorage<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span></a> 的实现，它将 state 同步到本地存储，以使其在页面刷新后保持不变。 用法与 useState 相似，不同之处在于我们传入了本地存储键，以便我们可以在页面加载时默认为该值，而不是指定的初始值。</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code>import { useState } from &quot;react&quot;;

// Usage
function App() {
  // Similar to useState but first arg is key to the value in local storage.
  const [name, setName] = useLocalStorage(&quot;name&quot;, &quot;Bob&quot;);

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        placeholder=&quot;Enter your name&quot;
        value={name}
        onChange={(e) =&gt; setName(e.target.value)}
      /&gt;
    &lt;/div&gt;
  );
}

// Hook
function useLocalStorage(key, initialValue) {
  // State to store our value
  // Pass initial state function to useState so logic is only executed once
  const [storedValue, setStoredValue] = useState(() =&gt; {
    try {
      // Get from local storage by key
      const item = window.localStorage.getItem(key);
      // Parse stored json or if none return initialValue
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      // If error also return initialValue
      console.log(error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState&#39;s setter function that ...
  // ... persists the new value to localStorage.
  const setValue = (value) =&gt; {
    try {
      // Allow value to be a function so we have same API as useState
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      // Save state
      setStoredValue(valueToStore);
      // Save to local storage
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      // A more advanced implementation would handle the error case
      console.log(error);
    }
  };

  return [storedValue, setValue];
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><p><strong>注意: 自定义 Hook 函数在定义时，也可以使用另一个自定义 Hook 函数。</strong></p><hr><h3 id="hook-使用约束" tabindex="-1"><a class="header-anchor" href="#hook-使用约束" aria-hidden="true">#</a> Hook 使用约束</h3><ol><li>只能在<strong>函数组件最顶层</strong>调用 Hook，不能在循环、条件判断或子函数中调用。</li><li>只能在<strong>函数组件</strong>或者是<strong>自定义 Hook 函数</strong>中调用，普通的 js 函数不能使用。</li></ol><hr><h3 id="hooks-怎么实现-class-组件的功能" tabindex="-1"><a class="header-anchor" href="#hooks-怎么实现-class-组件的功能" aria-hidden="true">#</a> Hooks 怎么实现 class 组件的功能</h3><p>Hooks 没有生命周期，但可以通过 Hook 来模拟生命周期的功能。</p><h4 id="constructor" tabindex="-1"><a class="header-anchor" href="#constructor" aria-hidden="true">#</a> constructor</h4><p>class 组件的构造函数一般是用于设置 state 或者给事件绑定 this 的。Hooks 中没有 this 指向的问题，而 state 可以通过 <code>useState</code>/<code>useReducer</code> 来实现。</p><h4 id="getderivedstatefromprops" tabindex="-1"><a class="header-anchor" href="#getderivedstatefromprops" aria-hidden="true">#</a> getDerivedStateFromProps</h4><p><code>getDerivedStateFromProps</code> 用于在组件 props 变化时派生 <code>state</code>。可以通过 Hook 这样实现:</p><div class="language-jsx ext-jsx line-numbers-mode"><pre class="language-jsx"><code>function ScrollView({ row }) {
  const [isScrollingDown, setIsScrollingDown] = useState(false);
  const [prevRow, setPrevRow] = useState(null);

  if (row !== prevRow) {
    // Row 自上次渲染以来发生过改变。更新 isScrollingDown。
    setIsScrollingDown(prevRow !== null &amp;&amp; row &gt; prevRow);
    setPrevRow(row);
  }

  return `Scrolling down: ${isScrollingDown}`;
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="shouldcomponentupdate" tabindex="-1"><a class="header-anchor" href="#shouldcomponentupdate" aria-hidden="true">#</a> shouldComponentUpdate</h4><p><code>shouldComponentUpdate</code> 可以根据 <code>props</code>/<code>state</code> 的新旧值变化决定是否更新组件，在函数组件中可以使用 <code>React.memo</code> 达到同样的效果。</p><p><code>React.memo</code> 默认只是浅比较 <code>props</code> 的变化，它的第一个参数是函数组件，第二个参数是可选的自定义比较函数，用于来比较新旧 <code>props</code>。</p><h4 id="hooks-没有实现的生命周期钩子" tabindex="-1"><a class="header-anchor" href="#hooks-没有实现的生命周期钩子" aria-hidden="true">#</a> Hooks 没有实现的生命周期钩子</h4><ul><li>getSnapshotBeforeUpdate</li><li>getDerivedStateFromError</li><li>componentDidCatch</li></ul><hr><h3 id="如何强制更新-hook-组件" tabindex="-1"><a class="header-anchor" href="#如何强制更新-hook-组件" aria-hidden="true">#</a> 如何强制更新 Hook 组件?</h3><p>可以设置一个<strong>没有实际作用</strong>的 <code>state</code>，然后强制更新 <code>state</code> 的值触发渲染。</p><hr><h3 id="类实例成员变量如何映射到-hooks" tabindex="-1"><a class="header-anchor" href="#类实例成员变量如何映射到-hooks" aria-hidden="true">#</a> 类实例成员变量如何映射到 Hooks?</h3><p>使用 <code>useRef</code> 设置可变数据。</p><hr><h3 id="hook-中如何获取旧的-props-和-state" tabindex="-1"><a class="header-anchor" href="#hook-中如何获取旧的-props-和-state" aria-hidden="true">#</a> Hook 中如何获取旧的 props 和 state</h3><p>可以通过 <code>useRef</code> 来保存数据，因为渲染时不会覆盖掉 <code>ref</code>。</p><h2 id="redux" tabindex="-1"><a class="header-anchor" href="#redux" aria-hidden="true">#</a> Redux</h2><h3 id="什么场景会考虑使用状态管理器" tabindex="-1"><a class="header-anchor" href="#什么场景会考虑使用状态管理器" aria-hidden="true">#</a> 什么场景会考虑使用状态管理器</h3><p>从使用的角度:</p><ol><li>用户的使用方式复杂</li><li>不同身份的用户有不同的使用方式 (区分普通用户和 admin)</li><li>多个用户之间可以协作</li><li>与服务器大量交互，或使用了 websocket</li><li>view 要从多个来源获取数据</li></ol><p>从组件的角度来看:</p><ol><li>某个组件的状态需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ol><hr><h3 id="redux-是什么-它遵循什么原则吗" tabindex="-1"><a class="header-anchor" href="#redux-是什么-它遵循什么原则吗" aria-hidden="true">#</a> redux 是什么? 它遵循什么原则吗?</h3><p>Redux 是状态容器与数据流管理。它的三大原则是:</p><ul><li>单一数据源</li><li>状态不可变</li><li>纯函数 (无副作用函数) 修改状态</li></ul><hr><h3 id="描述-redux-单向数据流" tabindex="-1"><a class="header-anchor" href="#描述-redux-单向数据流" aria-hidden="true">#</a> 描述 redux 单向数据流</h3><ol><li>Redux 内部维护一个 <code>state</code> 数据。这个 <code>state</code> 数据只能通过 <code>dispatch</code> 派生 <code>action</code> 事件才能修改。</li><li>若 Redux 使用了中间件，先经过全部中间件处理</li><li><code>dispatch</code> 触发事件后将 <code>action</code> 事件和当前的 <code>state</code> 数据传入给 <code>reducer</code>，由 <code>reducer</code> 对事件进行处理并返回更新后 <code>state</code> 数据。</li><li><code>reducer</code> 的返回值将用于更新 <code>state</code> 数据</li><li>如果需要获取 <code>state</code> 更新后的数据，可以调用 <code>subscribe</code> 方法，传递一个监听函数来订阅数据的变化。当数据更新后将会调用每个监听函数。</li><li>将获取到的 <code>state</code> 数据渲染到视图中。</li></ol><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/anran758/front-end-lab/edit/main/docs/topic/react.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页"><!--[--><!--]--> 在 GitHub 上编辑此页 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: anran758@gmail.com">anran758</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/front-end-lab/topic/vue.html" class="" aria-label="Vue.js"><!--[--><!--]--> Vue.js <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!----><!--]--></div>
    <script type="module" src="/front-end-lab/assets/app.7e3542fd.js" defer></script>
  </body>
</html>
