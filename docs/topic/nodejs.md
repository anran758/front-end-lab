# Node.js 与服务端

### 简述一下 Nodejs 的异步 IO 模型

1. **事件驱动：** 基于事件循环的模型，通过监听和响应事件实现异步编程。
2. **非阻塞 I/O：** 采用非阻塞的 I/O 操作方式，使得可以在进行 I/O 操作的同时执行其他代码。
3. **回调函数：** 大部分异步操作通过回调函数来处理结果，实现了异步编程的主要机制。
4. **事件触发器：** 提供事件触发器类来处理事件的监听和触发，用于模块之间的解耦和通信。
5. **单线程：** 尽管是单线程的，但通过事件循环和异步 I/O 模型，能够充分利用多核 CPU，实现高并发和高吞吐量的处理能力。

---

### 什么是 libuv?

libuv 是一个用于抽象非阻塞 I/O 操作的 C 库。他有以下几个特点：

- 集成了事件驱动的异步I/O模型。
- 它允许同时使用CPU和其他资源，同时仍然执行I/O操作，从而实现资源和网络的高效利用。
- 它促进了事件驱动的方法，其中使用基于回调的通知来执行 I/O 和其他活动。

**示例：** 假设我们有一个程序正在执行查询数据库的操作，而数据库查询可能需要一些时间来完成。如果程序在等待查询结果的同时被阻塞，那么 CPU 就会处于空闲状态，无法处理其他任务，从而造成系统资源的浪费。

![libuv](../_images/libuv.jpeg)

---

### 并发量大怎么解决?

**1.从代码层面进行优化**

- **异步编程**：利用Node.js的非阻塞I/O模型，确保应用使用异步API调用，避免阻塞主事件循环。
- **避免重计算**：使用缓存策略，如内存缓存或分布式缓存系统（如Redis），来存储重复计算的结果或常用数据。

**2.在应用架构层面调整**

- **微服务架构**：将大型应用拆分为小的、独立的服务，可以分别扩展，降低整体系统的复杂性。
- **无状态设计**：确保服务间的通信无状态，这样每个服务都可以独立扩展。

其中一个典型的例子就是云函数架构 (FaaS)，每个云函数都独立执行。如果一个云函数发生崩溃或遇到阻塞，它不会影响应用程序的其他部分正常运行。

**3.负载均衡**

- **使用反向代理**：通过 Nginx 或 HAProxy 等工具可以帮助分发入站请求到多个 Node.js 实例或服务器。
- **DNS轮询**：配置DNS以轮询方式分发请求到多个服务器，从而平衡负载。

**4.水平扩展**，即日常工作中常说 "扩容"。

- **增加实例**：通过增加更多的 Node.js 实例来分散负载。这可以在单台机器上实现，也可以跨多台机器实现。
- **容器化与编排**：使用 Docker 和 Kubernetes 等技术可以帮助自动管理和扩展应用程序的多个实例。

**5.优化数据库访问**

- **数据库索引**：根据业务需求，在合适的地方添加索引，以提高数据库查询的速度和效率。确保关键查询字段都建立了索引。
- **读写分离**：对于访问量大的数据库应用，通过实现主从复制及读写分离策略，可以有效分散读操作和写操作的压力，从而提升整体性能。

**6.设置缓存**

- **前端缓存**：使用 CDN 来缓存静态资源，减轻服务器压力。
- **后端缓存**：应用程序级别的缓存（例如Redis）可以存储常用数据或会话信息，减少数据库访问次数。

**7.限流和服务降级**

- **限流**：限制访问速率，防止系统过载。
- **服务降级**：在系统负载极高时，暂时关闭或降低某些非核心功能的服务质量。

比方说，在电商平台的大促销期间，为防止系统崩溃，可以限制每秒处理的用户请求数量，确保所有用户都能获得一致的服务体验。

---

### 如果你的 node 半夜服务挂了如何启动?

通过守护进程管理 Node.js 应用，在 Node.js 中最常用的守护进程是 `pm2`:

使用 pm2 启动应用:

``` bash
pm2 start app.js
```

设置开机自启，确保服务器重启后能自动启动：

``` bash
pm2 startup
```

---

### koa 的洋葱模型是怎么实现的

在 Koa 中，中间件就像洋葱的层层皮一样。当一个请求到达时，它首先经过最外层的中间件，然后通过 `next` 函数逐层向里传递，直到达到最内层。

每一层中间件都是独立的功能、可以做一些工作，然后再把请求传递给下一层。当请求处理完成后，Koa 会逆向执行这些中间件，从内层到外层，以便完成一些清理工作。

``` js
const Koa = require('koa');
const app = new Koa();

// 第一个中间件
app.use(async (ctx, next) => {
    console.log('Middleware 1 - Start');
    await next(); // 调用下一个中间件
    console.log('Middleware 1 - End');
});

// 第二个中间件
app.use(async (ctx, next) => {
    console.log('Middleware 2 - Start');
    await next(); // 调用下一个中间件
    console.log('Middleware 2 - End');
});

// 路由处理函数
app.use(async ctx => {
    console.log('Route Handler');
    ctx.body = 'Hello Koa!';
});

// 启动应用程序
app.listen(3000, () => {
    console.log('Server is running on port 3000');
});
```

---

### 在没有async await 的时候, koa是怎么实现的洋葱模型?

Koa 可以基于回调的方式来实现中间件的执行和控制流程：

``` js
const Koa = require('koa');
const app = new Koa();

// 第一个中间件
app.use((ctx, next) => {
    console.log('Middleware 1 - Start');
    // 调用下一个中间件函数
    return next(() => {
        console.log('Middleware 1 - End');
    });
});

// 第二个中间件
app.use((ctx, next) => {
    console.log('Middleware 2 - Start');
    // 调用下一个中间件函数
    return next(() => {
        console.log('Middleware 2 - End');
    });
});

// 路由处理函数
app.use(ctx => {
    console.log('Route Handler');
    ctx.body = 'Hello Koa!';
});

// 启动应用程序
app.listen(3000, () => {
    console.log('Server is running on port 3000');
});
```
